#pragma once
#define MAX_WEAPONS	48
#define FIRSTPERSON_TO_THIRDPERSON_VERTICAL_TOLERANCE_MIN 4.0f
#define FIRSTPERSON_TO_THIRDPERSON_VERTICAL_TOLERANCE_MAX 10.0f

const float m_flTeleportDistanceSqr = 4096.f;

const float CS_PLAYER_SPEED_STOPPED = 1.0f;

template < typename t >
__forceinline t vfunc(void* thisptr, uintptr_t idx) {
	return reinterpret_cast<t>((*reinterpret_cast<uintptr_t**>(thisptr))[idx]);
}

enum animstate_pose_param_idx_t {
	FIRST = 0,
	LEAN_YAW = FIRST,
	SPEED,
	LADDER_SPEED,
	LADDER_YAW,
	MOVE_YAW,
	RUN,
	BODY_YAW,
	BODY_PITCH,
	DEATH_YAW,
	L_STAND,
	JUMP_FALL,
	AIM_BLEND_STAND_IDLE,
	AIM_BLEND_CROUCH_IDLE,
	STRAFE_DIR,
	AIM_BLEND_STAND_WALK,
	AIM_BLEND_STAND_RUN,
	AIM_BLEND_CROUCH_WALK,
	MOVE_BLEND_WALK,
	MOVE_BLEND_RUN,
	MOVE_BLEND_CROUCH_WALK,
	//STRAFE_CROSS,
	COUNT,
};

enum animstate_layer_t {
	ANIMATION_LAYER_AIMMATRIX = 0,
	ANIMATION_LAYER_WEAPON_ACTION,
	ANIMATION_LAYER_WEAPON_ACTION_RECROUCH,
	ANIMATION_LAYER_ADJUST,
	ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL,  // fixed
	ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB, // fixed
	ANIMATION_LAYER_MOVEMENT_MOVE,          // still not fixed
	ANIMATION_LAYER_MOVEMENT_STRAFECHANGE,
	ANIMATION_LAYER_WHOLE_BODY,
	ANIMATION_LAYER_FLASHED,
	ANIMATION_LAYER_FLINCH,
	ANIMATION_LAYER_ALIVELOOP,
	ANIMATION_LAYER_LEAN,
	ANIMATION_LAYER_COUNT,
};

enum Hitboxes_t : int {
	HITBOX_HEAD = 0,
	HITBOX_NECK,
	HITBOX_LOWER_NECK,
	HITBOX_PELVIS,
	HITBOX_BODY,
	HITBOX_THORAX,
	HITBOX_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_R_THIGH,
	HITBOX_L_THIGH,
	HITBOX_R_CALF,
	HITBOX_L_CALF,
	HITBOX_R_FOOT,
	HITBOX_L_FOOT,
	HITBOX_R_HAND,
	HITBOX_L_HAND,
	HITBOX_R_UPPER_ARM,
	HITBOX_R_FOREARM,
	HITBOX_L_UPPER_ARM,
	HITBOX_L_FOREARM,
	HITBOX_MAX
};

enum struct e_life_state : std::uint8_t {
	alive,
	dying,
	dead,
	respawnable,
	discard_body
};

enum RenderFlags_t : uint32_t {
	STUDIO_NONE = 0x00000000,
	STUDIO_RENDER = 0x00000001,
	STUDIO_VIEWXFORMATTACHMENTS = 0x00000002,
	STUDIO_DRAWTRANSLUCENTSUBMODELS = 0x00000004,
	STUDIO_TWOPASS = 0x00000008,
	STUDIO_STATIC_LIGHTING = 0x00000010,
	STUDIO_WIREFRAME = 0x00000020,
	STUDIO_ITEM_BLINK = 0x00000040,
	STUDIO_NOSHADOWS = 0x00000080,
	STUDIO_WIREFRAME_VCOLLIDE = 0x00000100,
	STUDIO_NOLIGHTING_OR_CUBEMAP = 0x00000200,
	STUDIO_SKIP_FLEXES = 0x00000400,
	STUDIO_DONOTMODIFYSTENCILSTATE = 0x00000800,
	STUDIO_TRANSPARENCY = 0x80000000,
	STUDIO_SHADOWDEPTHTEXTURE = 0x40000000,
	STUDIO_SHADOWTEXTURE = 0x20000000,
	STUDIO_SKIP_DECALS = 0x10000000
};

enum BoneFlags_t : int {
	BONE_USED_BY_ANYTHING = 0x0007FF00,
	BONE_USED_BY_HITBOX = 0x00000100, // bone (or child) is used by a hit box
	BONE_USED_BY_ATTACHMENT = 0x00000200, // bone (or child) is used by an attachment point
	BONE_USED_BY_VERTEX_MASK = 0x0003FC00,
	BONE_USED_BY_VERTEX_LOD0 = 0x00000400, // bone (or child) is used by the toplevel model via skinned vertex
	BONE_USED_BY_VERTEX_LOD1 = 0x00000800,
	BONE_USED_BY_VERTEX_LOD2 = 0x00001000,
	BONE_USED_BY_VERTEX_LOD3 = 0x00002000,
	BONE_USED_BY_VERTEX_LOD4 = 0x00004000,
	BONE_USED_BY_VERTEX_LOD5 = 0x00008000,
	BONE_USED_BY_VERTEX_LOD6 = 0x00010000,
	BONE_USED_BY_VERTEX_LOD7 = 0x00020000,
	BONE_USED_BY_BONE_MERGE = 0x00040000,
	BONE_USED_BY_SERVER = BONE_USED_BY_HITBOX | BONE_USED_BY_VERTEX_LOD0 | BONE_USED_BY_VERTEX_LOD1 | BONE_USED_BY_VERTEX_LOD2 | BONE_USED_BY_VERTEX_LOD3
	| BONE_USED_BY_VERTEX_LOD4 | BONE_USED_BY_VERTEX_LOD5 | BONE_USED_BY_VERTEX_LOD6 | BONE_USED_BY_VERTEX_LOD7
};

enum CSWeaponType : int {
	WEAPONTYPE_UNKNOWN = -1,
	WEAPONTYPE_KNIFE,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_TASER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_HEALTHSHOT = 11
};

const char* const g_szWeaponPrefixLookupTable[] = {
	"knife",
	"pistol",
	"smg",
	"rifle",
	"shotgun",
	"sniper",
	"heavy",
	"c4",
	"grenade",
	"knife"
};


enum teams_t : int {
	TEAM_NOTEAM = 0,
	TEAM_SPECTATOR,
	TEAM_TERRORISTS,
	TEAM_COUNTERTERRORISTS
};

enum effects_t : int {
	EF_BONEMERGE = 0x001,	// Performs bone merge on client side
	EF_BRIGHTLIGHT = 0x002,	// DLIGHT centered at entity origin
	EF_DIMLIGHT = 0x004,	// player flashlight
	EF_NOINTERP = 0x008,	// don't interpolate the next frame
	EF_NOSHADOW = 0x010,	// Don't cast no shadow
	EF_NODRAW = 0x020,	// don't draw entity
	EF_NORECEIVESHADOW = 0x040,	// Don't receive no shadow
	EF_BONEMERGE_FASTCULL = 0x080,	// For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its
	EF_ITEM_BLINK = 0x100,	// blink an item so that the user notices it.
	EF_PARENT_ANIMATES = 0x200,	// always assume that the parent entity is animating
	EF_MAX_BITS = 10
};

enum InvalidatePhysicsBits_t : int {
	POSITION_CHANGED = 0x1,
	ANGLES_CHANGED = 0x2,
	VELOCITY_CHANGED = 0x4,
	ANIMATION_CHANGED = 0x8,
	BOUNDS_CHANGED = 0x10,        // Means render bounds have changed, so shadow decal projection is required, etc.
	SEQUENCE_CHANGED = 0x20,        // Means sequence has changed, only interesting when surrounding bounds depends on sequence
};

enum DataUpdateType_t : int {
	DATA_UPDATE_CREATED = 0,
	DATA_UPDATE_DATATABLE_CHANGED,
};

enum LifeStates_t : int {
	LIFE_ALIVE = 0,
	LIFE_DYING,
	LIFE_DEAD,
	LIFE_RESPAWNABLE,
	LIFE_DISCARDBODY,
};

enum PlayerFlags_t : int {
	FL_ONGROUND = (1 << 0),
	FL_DUCKING = (1 << 1),
	FL_WATERJUMP = (1 << 3),
	FL_ONTRAIN = (1 << 4),
	FL_INRAIN = (1 << 5),
	FL_FROZEN = (1 << 6),
	FL_ATCONTROLS = (1 << 7),
	FL_CLIENT = (1 << 8),
	FL_FAKECLIENT = (1 << 9),
	FL_INWATER = (1 << 10),
};

enum MoveType_t : int {
	MOVETYPE_NONE = 0,
	MOVETYPE_ISOMETRIC,
	MOVETYPE_WALK,
	MOVETYPE_STEP,
	MOVETYPE_FLY,
	MOVETYPE_FLYGRAVITY,
	MOVETYPE_VPHYSICS,
	MOVETYPE_PUSH,
	MOVETYPE_NOCLIP,
	MOVETYPE_LADDER,
	MOVETYPE_OBSERVER,
	MOVETYPE_CUSTOM,
	MOVETYPE_LAST = MOVETYPE_CUSTOM,
	MOVETYPE_MAX_BITS = 4,
};

enum ItemDefinitionIndex {
	ITEM_NONE = 0,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALIL = 13,
	WEAPON_M249,
	WEAPON_M4A4 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_ZONE_REPULSOR,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_ZEUS,
	WEAPON_P2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG553,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INC,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1S,
	WEAPON_USPS,
	WEAPON_CZ75 = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH = 516,
	WEAPON_KNIFE_CORD = 517,
	WEAPON_KNIFE_CANIS = 518,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE = 520,
	WEAPON_KNIFE_OUTDOOR = 521,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER = 523,
	WEAPON_KNIFE_SKELETON = 525,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034,
	GLOVE_HYDRA = 5035,
	MAX_ITEM_DEFINITION_INDEX,
};

enum Activity
{
	ACT_INVALID = -1,
	ACT_RESET,
	ACT_IDLE,
	ACT_TRANSITION,
	ACT_COVER,
	ACT_COVER_MED,
	ACT_COVER_LOW,
	ACT_WALK,
	ACT_WALK_AIM,
	ACT_WALK_CROUCH,
	ACT_WALK_CROUCH_AIM,
	ACT_RUN,
	ACT_RUN_AIM,
	ACT_RUN_CROUCH,
	ACT_RUN_CROUCH_AIM,
	ACT_RUN_PROTECTED,
	ACT_SCRIPT_CUSTOM_MOVE,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_RANGE_ATTACK1_LOW,
	ACT_RANGE_ATTACK2_LOW,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_DIERAGDOLL,
	ACT_FLY,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_SWIM,
	ACT_JUMP,
	ACT_HOP,
	ACT_LEAP,
	ACT_LAND,
	ACT_CLIMB_UP,
	ACT_CLIMB_DOWN,
	ACT_CLIMB_DISMOUNT,
	ACT_SHIPLADDER_UP,
	ACT_SHIPLADDER_DOWN,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_ALIEN_BURROW_IDLE,
	ACT_ALIEN_BURROW_OUT,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_SIGNAL_ADVANCE,
	ACT_SIGNAL_FORWARD,
	ACT_SIGNAL_GROUP,
	ACT_SIGNAL_HALT,
	ACT_SIGNAL_LEFT,
	ACT_SIGNAL_RIGHT,
	ACT_SIGNAL_TAKECOVER,
	ACT_LOOKBACK_RIGHT,
	ACT_LOOKBACK_LEFT,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_RELOAD_START,
	ACT_RELOAD_FINISH,
	ACT_RELOAD_LOW,
	ACT_ARM,
	ACT_DISARM,
	ACT_DROP_WEAPON,
	ACT_DROP_WEAPON_SHOTGUN,
	ACT_PICKUP_GROUND,
	ACT_PICKUP_RACK,
	ACT_IDLE_ANGRY,
	ACT_IDLE_RELAXED,
	ACT_IDLE_STIMULATED,
	ACT_IDLE_AGITATED,
	ACT_IDLE_STEALTH,
	ACT_IDLE_HURT,
	ACT_WALK_RELAXED,
	ACT_WALK_STIMULATED,
	ACT_WALK_AGITATED,
	ACT_WALK_STEALTH,
	ACT_RUN_RELAXED,
	ACT_RUN_STIMULATED,
	ACT_RUN_AGITATED,
	ACT_RUN_STEALTH,
	ACT_IDLE_AIM_RELAXED,
	ACT_IDLE_AIM_STIMULATED,
	ACT_IDLE_AIM_AGITATED,
	ACT_IDLE_AIM_STEALTH,
	ACT_WALK_AIM_RELAXED,
	ACT_WALK_AIM_STIMULATED,
	ACT_WALK_AIM_AGITATED,
	ACT_WALK_AIM_STEALTH,
	ACT_RUN_AIM_RELAXED,
	ACT_RUN_AIM_STIMULATED,
	ACT_RUN_AIM_AGITATED,
	ACT_RUN_AIM_STEALTH,
	ACT_CROUCHIDLE_STIMULATED,
	ACT_CROUCHIDLE_AIM_STIMULATED,
	ACT_CROUCHIDLE_AGITATED,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH_PHYSICS,
	ACT_FLINCH_HEAD_BACK,
	ACT_FLINCH_HEAD_LEFT,
	ACT_FLINCH_HEAD_RIGHT,
	ACT_FLINCH_CHEST_BACK,
	ACT_FLINCH_STOMACH_BACK,
	ACT_FLINCH_CROUCH_FRONT,
	ACT_FLINCH_CROUCH_BACK,
	ACT_FLINCH_CROUCH_LEFT,
	ACT_FLINCH_CROUCH_RIGHT,
	ACT_IDLE_ON_FIRE,
	ACT_WALK_ON_FIRE,
	ACT_RUN_ON_FIRE,
	ACT_RAPPEL_LOOP,
	ACT_180_LEFT,
	ACT_180_RIGHT,
	ACT_90_LEFT,
	ACT_90_RIGHT,
	ACT_STEP_LEFT,
	ACT_STEP_RIGHT,
	ACT_STEP_BACK,
	ACT_STEP_FORE,
	ACT_GESTURE_RANGE_ATTACK1,
	ACT_GESTURE_RANGE_ATTACK2,
	ACT_GESTURE_MELEE_ATTACK1,
	ACT_GESTURE_MELEE_ATTACK2,
	ACT_GESTURE_RANGE_ATTACK1_LOW,
	ACT_GESTURE_RANGE_ATTACK2_LOW,
	ACT_MELEE_ATTACK_SWING_GESTURE,
	ACT_GESTURE_SMALL_FLINCH,
	ACT_GESTURE_BIG_FLINCH,
	ACT_GESTURE_FLINCH_BLAST,
	ACT_GESTURE_FLINCH_BLAST_SHOTGUN,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN,
	ACT_GESTURE_FLINCH_HEAD,
	ACT_GESTURE_FLINCH_CHEST,
	ACT_GESTURE_FLINCH_STOMACH,
	ACT_GESTURE_FLINCH_LEFTARM,
	ACT_GESTURE_FLINCH_RIGHTARM,
	ACT_GESTURE_FLINCH_LEFTLEG,
	ACT_GESTURE_FLINCH_RIGHTLEG,
	ACT_GESTURE_TURN_LEFT,
	ACT_GESTURE_TURN_RIGHT,
	ACT_GESTURE_TURN_LEFT45,
	ACT_GESTURE_TURN_RIGHT45,
	ACT_GESTURE_TURN_LEFT90,
	ACT_GESTURE_TURN_RIGHT90,
	ACT_GESTURE_TURN_LEFT45_FLAT,
	ACT_GESTURE_TURN_RIGHT45_FLAT,
	ACT_GESTURE_TURN_LEFT90_FLAT,
	ACT_GESTURE_TURN_RIGHT90_FLAT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_DO_NOT_DISTURB,
	ACT_SPECIFIC_SEQUENCE,
	ACT_VM_DRAW,
	ACT_VM_HOLSTER,
	ACT_VM_IDLE,
	ACT_VM_FIDGET,
	ACT_VM_PULLBACK,
	ACT_VM_PULLBACK_HIGH,
	ACT_VM_PULLBACK_LOW,
	ACT_VM_THROW,
	ACT_VM_PULLPIN,
	ACT_VM_PRIMARYATTACK,
	ACT_VM_SECONDARYATTACK,
	ACT_VM_RELOAD,
	ACT_VM_DRYFIRE,
	ACT_VM_HITLEFT,
	ACT_VM_HITLEFT2,
	ACT_VM_HITRIGHT,
	ACT_VM_HITRIGHT2,
	ACT_VM_HITCENTER,
	ACT_VM_HITCENTER2,
	ACT_VM_MISSLEFT,
	ACT_VM_MISSLEFT2,
	ACT_VM_MISSRIGHT,
	ACT_VM_MISSRIGHT2,
	ACT_VM_MISSCENTER,
	ACT_VM_MISSCENTER2,
	ACT_VM_HAULBACK,
	ACT_VM_SWINGHARD,
	ACT_VM_SWINGMISS,
	ACT_VM_SWINGHIT,
	ACT_VM_IDLE_TO_LOWERED,
	ACT_VM_IDLE_LOWERED,
	ACT_VM_LOWERED_TO_IDLE,
	ACT_VM_RECOIL1,
	ACT_VM_RECOIL2,
	ACT_VM_RECOIL3,
	ACT_VM_PICKUP,
	ACT_VM_RELEASE,
	ACT_VM_ATTACH_SILENCER,
	ACT_VM_DETACH_SILENCER,
	ACT_VM_EMPTY_FIRE,
	ACT_VM_EMPTY_RELOAD,
	ACT_VM_EMPTY_DRAW,
	ACT_VM_EMPTY_IDLE,
	ACT_SLAM_STICKWALL_IDLE,
	ACT_SLAM_STICKWALL_ND_IDLE,
	ACT_SLAM_STICKWALL_ATTACH,
	ACT_SLAM_STICKWALL_ATTACH2,
	ACT_SLAM_STICKWALL_ND_ATTACH,
	ACT_SLAM_STICKWALL_ND_ATTACH2,
	ACT_SLAM_STICKWALL_DETONATE,
	ACT_SLAM_STICKWALL_DETONATOR_HOLSTER,
	ACT_SLAM_STICKWALL_DRAW,
	ACT_SLAM_STICKWALL_ND_DRAW,
	ACT_SLAM_STICKWALL_TO_THROW,
	ACT_SLAM_STICKWALL_TO_THROW_ND,
	ACT_SLAM_STICKWALL_TO_TRIPMINE_ND,
	ACT_SLAM_THROW_IDLE,
	ACT_SLAM_THROW_ND_IDLE,
	ACT_SLAM_THROW_THROW,
	ACT_SLAM_THROW_THROW2,
	ACT_SLAM_THROW_THROW_ND,
	ACT_SLAM_THROW_THROW_ND2,
	ACT_SLAM_THROW_DRAW,
	ACT_SLAM_THROW_ND_DRAW,
	ACT_SLAM_THROW_TO_STICKWALL,
	ACT_SLAM_THROW_TO_STICKWALL_ND,
	ACT_SLAM_THROW_DETONATE,
	ACT_SLAM_THROW_DETONATOR_HOLSTER,
	ACT_SLAM_THROW_TO_TRIPMINE_ND,
	ACT_SLAM_TRIPMINE_IDLE,
	ACT_SLAM_TRIPMINE_DRAW,
	ACT_SLAM_TRIPMINE_ATTACH,
	ACT_SLAM_TRIPMINE_ATTACH2,
	ACT_SLAM_TRIPMINE_TO_STICKWALL_ND,
	ACT_SLAM_TRIPMINE_TO_THROW_ND,
	ACT_SLAM_DETONATOR_IDLE,
	ACT_SLAM_DETONATOR_DRAW,
	ACT_SLAM_DETONATOR_DETONATE,
	ACT_SLAM_DETONATOR_HOLSTER,
	ACT_SLAM_DETONATOR_STICKWALL_DRAW,
	ACT_SLAM_DETONATOR_THROW_DRAW,
	ACT_SHOTGUN_RELOAD_START,
	ACT_SHOTGUN_RELOAD_FINISH,
	ACT_SHOTGUN_PUMP,
	ACT_SMG2_IDLE2,
	ACT_SMG2_FIRE2,
	ACT_SMG2_DRAW2,
	ACT_SMG2_RELOAD2,
	ACT_SMG2_DRYFIRE2,
	ACT_SMG2_TOAUTO,
	ACT_SMG2_TOBURST,
	ACT_PHYSCANNON_UPGRADE,
	ACT_RANGE_ATTACK_AR1,
	ACT_RANGE_ATTACK_AR2,
	ACT_RANGE_ATTACK_AR2_LOW,
	ACT_RANGE_ATTACK_AR2_GRENADE,
	ACT_RANGE_ATTACK_HMG1,
	ACT_RANGE_ATTACK_ML,
	ACT_RANGE_ATTACK_SMG1,
	ACT_RANGE_ATTACK_SMG1_LOW,
	ACT_RANGE_ATTACK_SMG2,
	ACT_RANGE_ATTACK_SHOTGUN,
	ACT_RANGE_ATTACK_SHOTGUN_LOW,
	ACT_RANGE_ATTACK_PISTOL,
	ACT_RANGE_ATTACK_PISTOL_LOW,
	ACT_RANGE_ATTACK_SLAM,
	ACT_RANGE_ATTACK_TRIPWIRE,
	ACT_RANGE_ATTACK_THROW,
	ACT_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_RANGE_ATTACK_RPG,
	ACT_MELEE_ATTACK_SWING,
	ACT_RANGE_AIM_LOW,
	ACT_RANGE_AIM_SMG1_LOW,
	ACT_RANGE_AIM_PISTOL_LOW,
	ACT_RANGE_AIM_AR2_LOW,
	ACT_COVER_PISTOL_LOW,
	ACT_COVER_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_AR1,
	ACT_GESTURE_RANGE_ATTACK_AR2,
	ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE,
	ACT_GESTURE_RANGE_ATTACK_HMG1,
	ACT_GESTURE_RANGE_ATTACK_ML,
	ACT_GESTURE_RANGE_ATTACK_SMG1,
	ACT_GESTURE_RANGE_ATTACK_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_SMG2,
	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,
	ACT_GESTURE_RANGE_ATTACK_PISTOL,
	ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW,
	ACT_GESTURE_RANGE_ATTACK_SLAM,
	ACT_GESTURE_RANGE_ATTACK_TRIPWIRE,
	ACT_GESTURE_RANGE_ATTACK_THROW,
	ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_GESTURE_MELEE_ATTACK_SWING,
	ACT_IDLE_RIFLE,
	ACT_IDLE_SMG1,
	ACT_IDLE_ANGRY_SMG1,
	ACT_IDLE_PISTOL,
	ACT_IDLE_ANGRY_PISTOL,
	ACT_IDLE_ANGRY_SHOTGUN,
	ACT_IDLE_STEALTH_PISTOL,
	ACT_IDLE_PACKAGE,
	ACT_WALK_PACKAGE,
	ACT_IDLE_SUITCASE,
	ACT_WALK_SUITCASE,
	ACT_IDLE_SMG1_RELAXED,
	ACT_IDLE_SMG1_STIMULATED,
	ACT_WALK_RIFLE_RELAXED,
	ACT_RUN_RIFLE_RELAXED,
	ACT_WALK_RIFLE_STIMULATED,
	ACT_RUN_RIFLE_STIMULATED,
	ACT_IDLE_AIM_RIFLE_STIMULATED,
	ACT_WALK_AIM_RIFLE_STIMULATED,
	ACT_RUN_AIM_RIFLE_STIMULATED,
	ACT_IDLE_SHOTGUN_RELAXED,
	ACT_IDLE_SHOTGUN_STIMULATED,
	ACT_IDLE_SHOTGUN_AGITATED,
	ACT_WALK_ANGRY,
	ACT_POLICE_HARASS1,
	ACT_POLICE_HARASS2,
	ACT_IDLE_MANNEDGUN,
	ACT_IDLE_MELEE,
	ACT_IDLE_ANGRY_MELEE,
	ACT_IDLE_RPG_RELAXED,
	ACT_IDLE_RPG,
	ACT_IDLE_ANGRY_RPG,
	ACT_COVER_LOW_RPG,
	ACT_WALK_RPG,
	ACT_RUN_RPG,
	ACT_WALK_CROUCH_RPG,
	ACT_RUN_CROUCH_RPG,
	ACT_WALK_RPG_RELAXED,
	ACT_RUN_RPG_RELAXED,
	ACT_WALK_RIFLE,
	ACT_WALK_AIM_RIFLE,
	ACT_WALK_CROUCH_RIFLE,
	ACT_WALK_CROUCH_AIM_RIFLE,
	ACT_RUN_RIFLE,
	ACT_RUN_AIM_RIFLE,
	ACT_RUN_CROUCH_RIFLE,
	ACT_RUN_CROUCH_AIM_RIFLE,
	ACT_RUN_STEALTH_PISTOL,
	ACT_WALK_AIM_SHOTGUN,
	ACT_RUN_AIM_SHOTGUN,
	ACT_WALK_PISTOL,
	ACT_RUN_PISTOL,
	ACT_WALK_AIM_PISTOL,
	ACT_RUN_AIM_PISTOL,
	ACT_WALK_STEALTH_PISTOL,
	ACT_WALK_AIM_STEALTH_PISTOL,
	ACT_RUN_AIM_STEALTH_PISTOL,
	ACT_RELOAD_PISTOL,
	ACT_RELOAD_PISTOL_LOW,
	ACT_RELOAD_SMG1,
	ACT_RELOAD_SMG1_LOW,
	ACT_RELOAD_SHOTGUN,
	ACT_RELOAD_SHOTGUN_LOW,
	ACT_GESTURE_RELOAD,
	ACT_GESTURE_RELOAD_PISTOL,
	ACT_GESTURE_RELOAD_SMG1,
	ACT_GESTURE_RELOAD_SHOTGUN,
	ACT_BUSY_LEAN_LEFT,
	ACT_BUSY_LEAN_LEFT_ENTRY,
	ACT_BUSY_LEAN_LEFT_EXIT,
	ACT_BUSY_LEAN_BACK,
	ACT_BUSY_LEAN_BACK_ENTRY,
	ACT_BUSY_LEAN_BACK_EXIT,
	ACT_BUSY_SIT_GROUND,
	ACT_BUSY_SIT_GROUND_ENTRY,
	ACT_BUSY_SIT_GROUND_EXIT,
	ACT_BUSY_SIT_CHAIR,
	ACT_BUSY_SIT_CHAIR_ENTRY,
	ACT_BUSY_SIT_CHAIR_EXIT,
	ACT_BUSY_STAND,
	ACT_BUSY_QUEUE,
	ACT_DUCK_DODGE,
	ACT_DIE_BARNACLE_SWALLOW,
	ACT_GESTURE_BARNACLE_STRANGLE,
	ACT_PHYSCANNON_DETACH,
	ACT_PHYSCANNON_ANIMATE,
	ACT_PHYSCANNON_ANIMATE_PRE,
	ACT_PHYSCANNON_ANIMATE_POST,
	ACT_DIE_FRONTSIDE,
	ACT_DIE_RIGHTSIDE,
	ACT_DIE_BACKSIDE,
	ACT_DIE_LEFTSIDE,
	ACT_DIE_CROUCH_FRONTSIDE,
	ACT_DIE_CROUCH_RIGHTSIDE,
	ACT_DIE_CROUCH_BACKSIDE,
	ACT_DIE_CROUCH_LEFTSIDE,
	ACT_OPEN_DOOR,
	ACT_DI_ALYX_ZOMBIE_MELEE,
	ACT_DI_ALYX_ZOMBIE_TORSO_MELEE,
	ACT_DI_ALYX_HEADCRAB_MELEE,
	ACT_DI_ALYX_ANTLION,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN64,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN26,
	ACT_READINESS_RELAXED_TO_STIMULATED,
	ACT_READINESS_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_AGITATED_TO_STIMULATED,
	ACT_READINESS_STIMULATED_TO_RELAXED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED,
	ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED,
	ACT_IDLE_CARRY,
	ACT_WALK_CARRY,
	ACT_STARTDYING,
	ACT_DYINGLOOP,
	ACT_DYINGTODEAD,
	ACT_RIDE_MANNED_GUN,
	ACT_VM_SPRINT_ENTER,
	ACT_VM_SPRINT_IDLE,
	ACT_VM_SPRINT_LEAVE,
	ACT_FIRE_START,
	ACT_FIRE_LOOP,
	ACT_FIRE_END,
	ACT_CROUCHING_GRENADEIDLE,
	ACT_CROUCHING_GRENADEREADY,
	ACT_CROUCHING_PRIMARYATTACK,
	ACT_OVERLAY_GRENADEIDLE,
	ACT_OVERLAY_GRENADEREADY,
	ACT_OVERLAY_PRIMARYATTACK,
	ACT_OVERLAY_SHIELD_UP,
	ACT_OVERLAY_SHIELD_DOWN,
	ACT_OVERLAY_SHIELD_UP_IDLE,
	ACT_OVERLAY_SHIELD_ATTACK,
	ACT_OVERLAY_SHIELD_KNOCKBACK,
	ACT_SHIELD_UP,
	ACT_SHIELD_DOWN,
	ACT_SHIELD_UP_IDLE,
	ACT_SHIELD_ATTACK,
	ACT_SHIELD_KNOCKBACK,
	ACT_CROUCHING_SHIELD_UP,
	ACT_CROUCHING_SHIELD_DOWN,
	ACT_CROUCHING_SHIELD_UP_IDLE,
	ACT_CROUCHING_SHIELD_ATTACK,
	ACT_CROUCHING_SHIELD_KNOCKBACK,
	ACT_TURNRIGHT45,
	ACT_TURNLEFT45,
	ACT_TURN,
	ACT_OBJ_ASSEMBLING,
	ACT_OBJ_DISMANTLING,
	ACT_OBJ_STARTUP,
	ACT_OBJ_RUNNING,
	ACT_OBJ_IDLE,
	ACT_OBJ_PLACING,
	ACT_OBJ_DETERIORATING,
	ACT_OBJ_UPGRADING,
	ACT_DEPLOY,
	ACT_DEPLOY_IDLE,
	ACT_UNDEPLOY,
	ACT_CROSSBOW_DRAW_UNLOADED,
	ACT_GAUSS_SPINUP,
	ACT_GAUSS_SPINCYCLE,
	ACT_VM_PRIMARYATTACK_SILENCED,
	ACT_VM_RELOAD_SILENCED,
	ACT_VM_DRYFIRE_SILENCED,
	ACT_VM_IDLE_SILENCED,
	ACT_VM_DRAW_SILENCED,
	ACT_VM_IDLE_EMPTY_LEFT,
	ACT_VM_DRYFIRE_LEFT,
	ACT_VM_IS_DRAW,
	ACT_VM_IS_HOLSTER,
	ACT_VM_IS_IDLE,
	ACT_VM_IS_PRIMARYATTACK,
	ACT_PLAYER_IDLE_FIRE,
	ACT_PLAYER_CROUCH_FIRE,
	ACT_PLAYER_CROUCH_WALK_FIRE,
	ACT_PLAYER_WALK_FIRE,
	ACT_PLAYER_RUN_FIRE,
	ACT_IDLETORUN,
	ACT_RUNTOIDLE,
	ACT_VM_DRAW_DEPLOYED,
	ACT_HL2MP_IDLE_MELEE,
	ACT_HL2MP_RUN_MELEE,
	ACT_HL2MP_IDLE_CROUCH_MELEE,
	ACT_HL2MP_WALK_CROUCH_MELEE,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,
	ACT_HL2MP_GESTURE_RELOAD_MELEE,
	ACT_HL2MP_JUMP_MELEE,
	ACT_VM_FIZZLE,
	ACT_MP_STAND_IDLE,
	ACT_MP_CROUCH_IDLE,
	ACT_MP_CROUCH_DEPLOYED_IDLE,
	ACT_MP_CROUCH_DEPLOYED,
	ACT_MP_DEPLOYED_IDLE,
	ACT_MP_RUN,
	ACT_MP_WALK,
	ACT_MP_AIRWALK,
	ACT_MP_CROUCHWALK,
	ACT_MP_SPRINT,
	ACT_MP_JUMP,
	ACT_MP_JUMP_START,
	ACT_MP_JUMP_FLOAT,
	ACT_MP_JUMP_LAND,
	ACT_MP_JUMP_IMPACT_N,
	ACT_MP_JUMP_IMPACT_E,
	ACT_MP_JUMP_IMPACT_W,
	ACT_MP_JUMP_IMPACT_S,
	ACT_MP_JUMP_IMPACT_TOP,
	ACT_MP_DOUBLEJUMP,
	ACT_MP_SWIM,
	ACT_MP_DEPLOYED,
	ACT_MP_SWIM_DEPLOYED,
	ACT_MP_VCD,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_STAND_SECONDARYFIRE,
	ACT_MP_ATTACK_STAND_GRENADE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_SECONDARYFIRE,
	ACT_MP_ATTACK_CROUCH_GRENADE,
	ACT_MP_ATTACK_SWIM_PRIMARYFIRE,
	ACT_MP_ATTACK_SWIM_SECONDARYFIRE,
	ACT_MP_ATTACK_SWIM_GRENADE,
	ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE,
	ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE,
	ACT_MP_ATTACK_AIRWALK_GRENADE,
	ACT_MP_RELOAD_STAND,
	ACT_MP_RELOAD_STAND_LOOP,
	ACT_MP_RELOAD_STAND_END,
	ACT_MP_RELOAD_CROUCH,
	ACT_MP_RELOAD_CROUCH_LOOP,
	ACT_MP_RELOAD_CROUCH_END,
	ACT_MP_RELOAD_SWIM,
	ACT_MP_RELOAD_SWIM_LOOP,
	ACT_MP_RELOAD_SWIM_END,
	ACT_MP_RELOAD_AIRWALK,
	ACT_MP_RELOAD_AIRWALK_LOOP,
	ACT_MP_RELOAD_AIRWALK_END,
	ACT_MP_ATTACK_STAND_PREFIRE,
	ACT_MP_ATTACK_STAND_POSTFIRE,
	ACT_MP_ATTACK_STAND_STARTFIRE,
	ACT_MP_ATTACK_CROUCH_PREFIRE,
	ACT_MP_ATTACK_CROUCH_POSTFIRE,
	ACT_MP_ATTACK_SWIM_PREFIRE,
	ACT_MP_ATTACK_SWIM_POSTFIRE,
	ACT_MP_STAND_PRIMARY,
	ACT_MP_CROUCH_PRIMARY,
	ACT_MP_RUN_PRIMARY,
	ACT_MP_WALK_PRIMARY,
	ACT_MP_AIRWALK_PRIMARY,
	ACT_MP_CROUCHWALK_PRIMARY,
	ACT_MP_JUMP_PRIMARY,
	ACT_MP_JUMP_START_PRIMARY,
	ACT_MP_JUMP_FLOAT_PRIMARY,
	ACT_MP_JUMP_LAND_PRIMARY,
	ACT_MP_SWIM_PRIMARY,
	ACT_MP_DEPLOYED_PRIMARY,
	ACT_MP_SWIM_DEPLOYED_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_PRIMARY,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_SWIM_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP,
	ACT_MP_RELOAD_STAND_PRIMARY_END,
	ACT_MP_RELOAD_CROUCH_PRIMARY,
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END,
	ACT_MP_RELOAD_SWIM_PRIMARY,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP,
	ACT_MP_RELOAD_SWIM_PRIMARY_END,
	ACT_MP_RELOAD_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_PRIMARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY,
	ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY,
	ACT_MP_STAND_SECONDARY,
	ACT_MP_CROUCH_SECONDARY,
	ACT_MP_RUN_SECONDARY,
	ACT_MP_WALK_SECONDARY,
	ACT_MP_AIRWALK_SECONDARY,
	ACT_MP_CROUCHWALK_SECONDARY,
	ACT_MP_JUMP_SECONDARY,
	ACT_MP_JUMP_START_SECONDARY,
	ACT_MP_JUMP_FLOAT_SECONDARY,
	ACT_MP_JUMP_LAND_SECONDARY,
	ACT_MP_SWIM_SECONDARY,
	ACT_MP_ATTACK_STAND_SECONDARY,
	ACT_MP_ATTACK_CROUCH_SECONDARY,
	ACT_MP_ATTACK_SWIM_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY_LOOP,
	ACT_MP_RELOAD_STAND_SECONDARY_END,
	ACT_MP_RELOAD_CROUCH_SECONDARY,
	ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP,
	ACT_MP_RELOAD_CROUCH_SECONDARY_END,
	ACT_MP_RELOAD_SWIM_SECONDARY,
	ACT_MP_RELOAD_SWIM_SECONDARY_LOOP,
	ACT_MP_RELOAD_SWIM_SECONDARY_END,
	ACT_MP_RELOAD_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY,
	ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY,
	ACT_MP_STAND_MELEE,
	ACT_MP_CROUCH_MELEE,
	ACT_MP_RUN_MELEE,
	ACT_MP_WALK_MELEE,
	ACT_MP_AIRWALK_MELEE,
	ACT_MP_CROUCHWALK_MELEE,
	ACT_MP_JUMP_MELEE,
	ACT_MP_JUMP_START_MELEE,
	ACT_MP_JUMP_FLOAT_MELEE,
	ACT_MP_JUMP_LAND_MELEE,
	ACT_MP_SWIM_MELEE,
	ACT_MP_ATTACK_STAND_MELEE,
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_MELEE,
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY,
	ACT_MP_ATTACK_SWIM_MELEE,
	ACT_MP_ATTACK_AIRWALK_MELEE,
	ACT_MP_ATTACK_STAND_GRENADE_MELEE,
	ACT_MP_ATTACK_CROUCH_GRENADE_MELEE,
	ACT_MP_ATTACK_SWIM_GRENADE_MELEE,
	ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE,
	ACT_MP_STAND_ITEM1,
	ACT_MP_CROUCH_ITEM1,
	ACT_MP_RUN_ITEM1,
	ACT_MP_WALK_ITEM1,
	ACT_MP_AIRWALK_ITEM1,
	ACT_MP_CROUCHWALK_ITEM1,
	ACT_MP_JUMP_ITEM1,
	ACT_MP_JUMP_START_ITEM1,
	ACT_MP_JUMP_FLOAT_ITEM1,
	ACT_MP_JUMP_LAND_ITEM1,
	ACT_MP_SWIM_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM1,
	ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM1,
	ACT_MP_ATTACK_AIRWALK_ITEM1,
	ACT_MP_STAND_ITEM2,
	ACT_MP_CROUCH_ITEM2,
	ACT_MP_RUN_ITEM2,
	ACT_MP_WALK_ITEM2,
	ACT_MP_AIRWALK_ITEM2,
	ACT_MP_CROUCHWALK_ITEM2,
	ACT_MP_JUMP_ITEM2,
	ACT_MP_JUMP_START_ITEM2,
	ACT_MP_JUMP_FLOAT_ITEM2,
	ACT_MP_JUMP_LAND_ITEM2,
	ACT_MP_SWIM_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM2,
	ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM2,
	ACT_MP_ATTACK_AIRWALK_ITEM2,
	ACT_MP_GESTURE_FLINCH,
	ACT_MP_GESTURE_FLINCH_PRIMARY,
	ACT_MP_GESTURE_FLINCH_SECONDARY,
	ACT_MP_GESTURE_FLINCH_MELEE,
	ACT_MP_GESTURE_FLINCH_ITEM1,
	ACT_MP_GESTURE_FLINCH_ITEM2,
	ACT_MP_GESTURE_FLINCH_HEAD,
	ACT_MP_GESTURE_FLINCH_CHEST,
	ACT_MP_GESTURE_FLINCH_STOMACH,
	ACT_MP_GESTURE_FLINCH_LEFTARM,
	ACT_MP_GESTURE_FLINCH_RIGHTARM,
	ACT_MP_GESTURE_FLINCH_LEFTLEG,
	ACT_MP_GESTURE_FLINCH_RIGHTLEG,
	ACT_MP_GRENADE1_DRAW,
	ACT_MP_GRENADE1_IDLE,
	ACT_MP_GRENADE1_ATTACK,
	ACT_MP_GRENADE2_DRAW,
	ACT_MP_GRENADE2_IDLE,
	ACT_MP_GRENADE2_ATTACK,
	ACT_MP_PRIMARY_GRENADE1_DRAW,
	ACT_MP_PRIMARY_GRENADE1_IDLE,
	ACT_MP_PRIMARY_GRENADE1_ATTACK,
	ACT_MP_PRIMARY_GRENADE2_DRAW,
	ACT_MP_PRIMARY_GRENADE2_IDLE,
	ACT_MP_PRIMARY_GRENADE2_ATTACK,
	ACT_MP_SECONDARY_GRENADE1_DRAW,
	ACT_MP_SECONDARY_GRENADE1_IDLE,
	ACT_MP_SECONDARY_GRENADE1_ATTACK,
	ACT_MP_SECONDARY_GRENADE2_DRAW,
	ACT_MP_SECONDARY_GRENADE2_IDLE,
	ACT_MP_SECONDARY_GRENADE2_ATTACK,
	ACT_MP_MELEE_GRENADE1_DRAW,
	ACT_MP_MELEE_GRENADE1_IDLE,
	ACT_MP_MELEE_GRENADE1_ATTACK,
	ACT_MP_MELEE_GRENADE2_DRAW,
	ACT_MP_MELEE_GRENADE2_IDLE,
	ACT_MP_MELEE_GRENADE2_ATTACK,
	ACT_MP_ITEM1_GRENADE1_DRAW,
	ACT_MP_ITEM1_GRENADE1_IDLE,
	ACT_MP_ITEM1_GRENADE1_ATTACK,
	ACT_MP_ITEM1_GRENADE2_DRAW,
	ACT_MP_ITEM1_GRENADE2_IDLE,
	ACT_MP_ITEM1_GRENADE2_ATTACK,
	ACT_MP_ITEM2_GRENADE1_DRAW,
	ACT_MP_ITEM2_GRENADE1_IDLE,
	ACT_MP_ITEM2_GRENADE1_ATTACK,
	ACT_MP_ITEM2_GRENADE2_DRAW,
	ACT_MP_ITEM2_GRENADE2_IDLE,
	ACT_MP_ITEM2_GRENADE2_ATTACK,
	ACT_MP_STAND_BUILDING,
	ACT_MP_CROUCH_BUILDING,
	ACT_MP_RUN_BUILDING,
	ACT_MP_WALK_BUILDING,
	ACT_MP_AIRWALK_BUILDING,
	ACT_MP_CROUCHWALK_BUILDING,
	ACT_MP_JUMP_BUILDING,
	ACT_MP_JUMP_START_BUILDING,
	ACT_MP_JUMP_FLOAT_BUILDING,
	ACT_MP_JUMP_LAND_BUILDING,
	ACT_MP_SWIM_BUILDING,
	ACT_MP_ATTACK_STAND_BUILDING,
	ACT_MP_ATTACK_CROUCH_BUILDING,
	ACT_MP_ATTACK_SWIM_BUILDING,
	ACT_MP_ATTACK_AIRWALK_BUILDING,
	ACT_MP_ATTACK_STAND_GRENADE_BUILDING,
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING,
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING,
	ACT_MP_STAND_PDA,
	ACT_MP_CROUCH_PDA,
	ACT_MP_RUN_PDA,
	ACT_MP_WALK_PDA,
	ACT_MP_AIRWALK_PDA,
	ACT_MP_CROUCHWALK_PDA,
	ACT_MP_JUMP_PDA,
	ACT_MP_JUMP_START_PDA,
	ACT_MP_JUMP_FLOAT_PDA,
	ACT_MP_JUMP_LAND_PDA,
	ACT_MP_SWIM_PDA,
	ACT_MP_ATTACK_STAND_PDA,
	ACT_MP_ATTACK_SWIM_PDA,
	ACT_MP_GESTURE_VC_HANDMOUTH,
	ACT_MP_GESTURE_VC_FINGERPOINT,
	ACT_MP_GESTURE_VC_FISTPUMP,
	ACT_MP_GESTURE_VC_THUMBSUP,
	ACT_MP_GESTURE_VC_NODYES,
	ACT_MP_GESTURE_VC_NODNO,
	ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY,
	ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY,
	ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY,
	ACT_MP_GESTURE_VC_NODYES_PRIMARY,
	ACT_MP_GESTURE_VC_NODNO_PRIMARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY,
	ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY,
	ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY,
	ACT_MP_GESTURE_VC_NODYES_SECONDARY,
	ACT_MP_GESTURE_VC_NODNO_SECONDARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_MELEE,
	ACT_MP_GESTURE_VC_FINGERPOINT_MELEE,
	ACT_MP_GESTURE_VC_FISTPUMP_MELEE,
	ACT_MP_GESTURE_VC_THUMBSUP_MELEE,
	ACT_MP_GESTURE_VC_NODYES_MELEE,
	ACT_MP_GESTURE_VC_NODNO_MELEE,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM1,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM1,
	ACT_MP_GESTURE_VC_NODYES_ITEM1,
	ACT_MP_GESTURE_VC_NODNO_ITEM1,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM2,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM2,
	ACT_MP_GESTURE_VC_NODYES_ITEM2,
	ACT_MP_GESTURE_VC_NODNO_ITEM2,
	ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING,
	ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING,
	ACT_MP_GESTURE_VC_FISTPUMP_BUILDING,
	ACT_MP_GESTURE_VC_THUMBSUP_BUILDING,
	ACT_MP_GESTURE_VC_NODYES_BUILDING,
	ACT_MP_GESTURE_VC_NODNO_BUILDING,
	ACT_MP_GESTURE_VC_HANDMOUTH_PDA,
	ACT_MP_GESTURE_VC_FINGERPOINT_PDA,
	ACT_MP_GESTURE_VC_FISTPUMP_PDA,
	ACT_MP_GESTURE_VC_THUMBSUP_PDA,
	ACT_MP_GESTURE_VC_NODYES_PDA,
	ACT_MP_GESTURE_VC_NODNO_PDA,
	ACT_VM_UNUSABLE,
	ACT_VM_UNUSABLE_TO_USABLE,
	ACT_VM_USABLE_TO_UNUSABLE,
	ACT_PRIMARY_VM_DRAW,
	ACT_PRIMARY_VM_HOLSTER,
	ACT_PRIMARY_VM_IDLE,
	ACT_PRIMARY_VM_PULLBACK,
	ACT_PRIMARY_VM_PRIMARYATTACK,
	ACT_PRIMARY_VM_SECONDARYATTACK,
	ACT_PRIMARY_VM_RELOAD,
	ACT_PRIMARY_VM_DRYFIRE,
	ACT_PRIMARY_VM_IDLE_TO_LOWERED,
	ACT_PRIMARY_VM_IDLE_LOWERED,
	ACT_PRIMARY_VM_LOWERED_TO_IDLE,
	ACT_SECONDARY_VM_DRAW,
	ACT_SECONDARY_VM_HOLSTER,
	ACT_SECONDARY_VM_IDLE,
	ACT_SECONDARY_VM_PULLBACK,
	ACT_SECONDARY_VM_PRIMARYATTACK,
	ACT_SECONDARY_VM_SECONDARYATTACK,
	ACT_SECONDARY_VM_RELOAD,
	ACT_SECONDARY_VM_DRYFIRE,
	ACT_SECONDARY_VM_IDLE_TO_LOWERED,
	ACT_SECONDARY_VM_IDLE_LOWERED,
	ACT_SECONDARY_VM_LOWERED_TO_IDLE,
	ACT_MELEE_VM_DRAW,
	ACT_MELEE_VM_HOLSTER,
	ACT_MELEE_VM_IDLE,
	ACT_MELEE_VM_PULLBACK,
	ACT_MELEE_VM_PRIMARYATTACK,
	ACT_MELEE_VM_SECONDARYATTACK,
	ACT_MELEE_VM_RELOAD,
	ACT_MELEE_VM_DRYFIRE,
	ACT_MELEE_VM_IDLE_TO_LOWERED,
	ACT_MELEE_VM_IDLE_LOWERED,
	ACT_MELEE_VM_LOWERED_TO_IDLE,
	ACT_PDA_VM_DRAW,
	ACT_PDA_VM_HOLSTER,
	ACT_PDA_VM_IDLE,
	ACT_PDA_VM_PULLBACK,
	ACT_PDA_VM_PRIMARYATTACK,
	ACT_PDA_VM_SECONDARYATTACK,
	ACT_PDA_VM_RELOAD,
	ACT_PDA_VM_DRYFIRE,
	ACT_PDA_VM_IDLE_TO_LOWERED,
	ACT_PDA_VM_IDLE_LOWERED,
	ACT_PDA_VM_LOWERED_TO_IDLE,
	ACT_ITEM1_VM_DRAW,
	ACT_ITEM1_VM_HOLSTER,
	ACT_ITEM1_VM_IDLE,
	ACT_ITEM1_VM_PULLBACK,
	ACT_ITEM1_VM_PRIMARYATTACK,
	ACT_ITEM1_VM_SECONDARYATTACK,
	ACT_ITEM1_VM_RELOAD,
	ACT_ITEM1_VM_DRYFIRE,
	ACT_ITEM1_VM_IDLE_TO_LOWERED,
	ACT_ITEM1_VM_IDLE_LOWERED,
	ACT_ITEM1_VM_LOWERED_TO_IDLE,
	ACT_ITEM2_VM_DRAW,
	ACT_ITEM2_VM_HOLSTER,
	ACT_ITEM2_VM_IDLE,
	ACT_ITEM2_VM_PULLBACK,
	ACT_ITEM2_VM_PRIMARYATTACK,
	ACT_ITEM2_VM_SECONDARYATTACK,
	ACT_ITEM2_VM_RELOAD,
	ACT_ITEM2_VM_DRYFIRE,
	ACT_ITEM2_VM_IDLE_TO_LOWERED,
	ACT_ITEM2_VM_IDLE_LOWERED,
	ACT_ITEM2_VM_LOWERED_TO_IDLE,
	ACT_RELOAD_SUCCEED,
	ACT_RELOAD_FAIL,
	ACT_WALK_AIM_AUTOGUN,
	ACT_RUN_AIM_AUTOGUN,
	ACT_IDLE_AUTOGUN,
	ACT_IDLE_AIM_AUTOGUN,
	ACT_RELOAD_AUTOGUN,
	ACT_CROUCH_IDLE_AUTOGUN,
	ACT_RANGE_ATTACK_AUTOGUN,
	ACT_JUMP_AUTOGUN,
	ACT_IDLE_AIM_PISTOL,
	ACT_WALK_AIM_DUAL,
	ACT_RUN_AIM_DUAL,
	ACT_IDLE_DUAL,
	ACT_IDLE_AIM_DUAL,
	ACT_RELOAD_DUAL,
	ACT_CROUCH_IDLE_DUAL,
	ACT_RANGE_ATTACK_DUAL,
	ACT_JUMP_DUAL,
	ACT_IDLE_SHOTGUN,
	ACT_IDLE_AIM_SHOTGUN,
	ACT_CROUCH_IDLE_SHOTGUN,
	ACT_JUMP_SHOTGUN,
	ACT_IDLE_AIM_RIFLE,
	ACT_RELOAD_RIFLE,
	ACT_CROUCH_IDLE_RIFLE,
	ACT_RANGE_ATTACK_RIFLE,
	ACT_JUMP_RIFLE,
	ACT_SLEEP,
	ACT_WAKE,
	ACT_FLICK_LEFT,
	ACT_FLICK_LEFT_MIDDLE,
	ACT_FLICK_RIGHT_MIDDLE,
	ACT_FLICK_RIGHT,
	ACT_SPINAROUND,
	ACT_PREP_TO_FIRE,
	ACT_FIRE,
	ACT_FIRE_RECOVER,
	ACT_SPRAY,
	ACT_PREP_EXPLODE,
	ACT_EXPLODE,
	ACT_DOTA_IDLE,
	ACT_DOTA_RUN,
	ACT_DOTA_ATTACK,
	ACT_DOTA_ATTACK_EVENT,
	ACT_DOTA_DIE,
	ACT_DOTA_FLINCH,
	ACT_DOTA_DISABLED,
	ACT_DOTA_CAST_ABILITY_1,
	ACT_DOTA_CAST_ABILITY_2,
	ACT_DOTA_CAST_ABILITY_3,
	ACT_DOTA_CAST_ABILITY_4,
	ACT_DOTA_OVERRIDE_ABILITY_1,
	ACT_DOTA_OVERRIDE_ABILITY_2,
	ACT_DOTA_OVERRIDE_ABILITY_3,
	ACT_DOTA_OVERRIDE_ABILITY_4,
	ACT_DOTA_CHANNEL_ABILITY_1,
	ACT_DOTA_CHANNEL_ABILITY_2,
	ACT_DOTA_CHANNEL_ABILITY_3,
	ACT_DOTA_CHANNEL_ABILITY_4,
	ACT_DOTA_CHANNEL_END_ABILITY_1,
	ACT_DOTA_CHANNEL_END_ABILITY_2,
	ACT_DOTA_CHANNEL_END_ABILITY_3,
	ACT_DOTA_CHANNEL_END_ABILITY_4,
	ACT_MP_RUN_SPEEDPAINT,
	ACT_MP_LONG_FALL,
	ACT_MP_TRACTORBEAM_FLOAT,
	ACT_MP_DEATH_CRUSH,
	ACT_MP_RUN_SPEEDPAINT_PRIMARY,
	ACT_MP_DROWNING_PRIMARY,
	ACT_MP_LONG_FALL_PRIMARY,
	ACT_MP_TRACTORBEAM_FLOAT_PRIMARY,
	ACT_MP_DEATH_CRUSH_PRIMARY,
	ACT_DIE_STAND,
	ACT_DIE_STAND_HEADSHOT,
	ACT_DIE_CROUCH,
	ACT_DIE_CROUCH_HEADSHOT,
	ACT_CSGO_NULL,
	ACT_CSGO_DEFUSE,
	ACT_CSGO_DEFUSE_WITH_KIT,
	ACT_CSGO_FLASHBANG_REACTION,
	ACT_CSGO_FIRE_PRIMARY,
	ACT_CSGO_FIRE_PRIMARY_OPT_1,
	ACT_CSGO_FIRE_PRIMARY_OPT_2,
	ACT_CSGO_FIRE_SECONDARY,
	ACT_CSGO_FIRE_SECONDARY_OPT_1,
	ACT_CSGO_FIRE_SECONDARY_OPT_2,
	ACT_CSGO_RELOAD,
	ACT_CSGO_RELOAD_START,
	ACT_CSGO_RELOAD_LOOP,
	ACT_CSGO_RELOAD_END,
	ACT_CSGO_OPERATE,
	ACT_CSGO_DEPLOY,
	ACT_CSGO_CATCH,
	ACT_CSGO_SILENCER_DETACH,
	ACT_CSGO_SILENCER_ATTACH,
	ACT_CSGO_TWITCH,
	ACT_CSGO_TWITCH_BUYZONE,
	ACT_CSGO_PLANT_BOMB,
	ACT_CSGO_IDLE_TURN_BALANCEADJUST,
	ACT_CSGO_IDLE_ADJUST_STOPPEDMOVING,
	ACT_CSGO_ALIVE_LOOP,
	ACT_CSGO_FLINCH,
	ACT_CSGO_FLINCH_HEAD,
	ACT_CSGO_FLINCH_MOLOTOV,
	ACT_CSGO_JUMP,
	ACT_CSGO_FALL,
	ACT_CSGO_CLIMB_LADDER,
	ACT_CSGO_LAND_LIGHT,
	ACT_CSGO_LAND_HEAVY,
	ACT_CSGO_EXIT_LADDER_TOP,
	ACT_CSGO_EXIT_LADDER_BOTTOM,
};

enum Weapons_t : int {
	DEAGLE = 1,
	ELITE = 2,
	FIVESEVEN = 3,
	GLOCK = 4,
	AK47 = 7,
	AUG = 8,
	AWP = 9,
	FAMAS = 10,
	G3SG1 = 11,
	GALIL = 13,
	M249 = 14,
	M4A4 = 16,
	MAC10 = 17,
	P90 = 19,
	UMP45 = 24,
	XM1014 = 25,
	BIZON = 26,
	MAG7 = 27,
	NEGEV = 28,
	SAWEDOFF = 29,
	TEC9 = 30,
	ZEUS = 31,
	P2000 = 32,
	MP7 = 33,
	MP9 = 34,
	NOVA = 35,
	P250 = 36,
	SCAR20 = 38,
	SG553 = 39,
	SSG08 = 40,
	KNIFE_T = 42,
	FLASHBANG = 43,
	HEGRENADE = 44,
	SMOKE = 45,
	MOLOTOV = 46,
	DECOY = 47,
	FIREBOMB = 48,
	C4 = 49,
	MUSICKIT = 58,
	KNIFE_CT = 59,
	M4A1S = 60,
	USPS = 61,
	TRADEUPCONTRACT = 62,
	CZ75A = 63,
	REVOLVER = 64,
	KNIFE_BAYONET = 500,
	KNIFE_FLIP = 505,
	KNIFE_GUT = 506,
	KNIFE_KARAMBIT = 507,
	KNIFE_M9_BAYONET = 508,
	KNIFE_HUNTSMAN = 509,
	KNIFE_FALCHION = 512,
	KNIFE_BOWIE = 514,
	KNIFE_BUTTERFLY = 515,
	KNIFE_SHADOW_DAGGERS = 516,
	GRENADE_UNKNOWN = -1,
};

struct RenderableInstance_t {
	uint8_t m_alpha;
	__forceinline RenderableInstance_t() : m_alpha{ 255ui8 } {}
};

class IHandleEntity {
public:
	virtual ~IHandleEntity() {}
	virtual void SetRefEHandle(const CBaseHandle& handle) = 0;
	virtual const ulong_t& GetRefEHandle() const = 0;
};

enum SolidType_t {
	solid_none = 0,
	solid_bsp,
	solid_bbox,
	solid_obb,
	solid_obb_yaw,
	solid_custom,
	solid_vphysics,
	solid_last
};

class IClientUnknown;

class IClientCollideable {
public:
	virtual IHandleEntity* GetEntityHandle() = 0;
	virtual vec3_t& OBBMins() const = 0;
	virtual vec3_t& OBBMaxs() const = 0;
	virtual void WorldSpaecTriggerBounds(vec3_t* world_mins, vec3_t* world_maxs) const = 0;
	virtual bool TestCollision(const Ray& ray, unsigned int contents_mask, CGameTrace& tr) = 0;
	virtual bool TestHitboxes(const Ray& ray, unsigned int contents_mask, CGameTrace& tr) = 0;
	virtual int GetCollisionModelIndex() = 0;
	virtual const model_t* GetCollisionModel() = 0;
	virtual vec3_t& GetCollisionOrigin() const = 0;
	virtual ang_t& GetCollisionAngles() const = 0;
	virtual const matrix3x4_t& CollisionToWorldTransform() const = 0;
	virtual SolidType_t GetSolid() const = 0;
	virtual int GetSolidFlags() const = 0;
	virtual IClientUnknown* GetIClientUnknown() = 0;
	virtual int GetCollisionGroup() const = 0;
	virtual void WorldSpaceSurroundingBounds(vec3_t* mins, vec3_t* maxs) = 0;
	virtual unsigned int GetRequiredTriggerFlags() const = 0;
	virtual const matrix3x4_t* GetRootParentToWorldTransform() const = 0;
	virtual void* GetVPhysicsObject() const = 0;
};

class IClientRenderable {
public:
	virtual IClientUnknown* GetIClientUnknown() = 0;
	const model_t* GetModel();
	bool SetupBones(matrix3x4_t* pBoneToWorld, int nMaxBones, int boneMask, float currentTime);
	void GetRenderBounds(vec3_t& mins, vec3_t& maxs);
};

class IClientUnknown : public IHandleEntity {
public:
	virtual IClientCollideable* GetCollideable() = 0;
	virtual void* GetClientNetworkable() = 0;
	virtual void* GetClientRenderable() = 0;
	virtual void* GetIClientEntity() = 0;
	virtual Entity* GetBaseEntity() = 0;
	virtual void* GetClientThinkable() = 0;
	virtual void* GetClientAlphaProperty() = 0;
};

#define CUSTOM_OFFSET( name, type, offset ) \
__forceinline type& name( ) \
{\
    return *( type* )( ( DWORD )( this ) + offset ); \
}\

enum entityflags_t : int {
	EFL_KILLME = (1 << 0),	// This entity is marked for death -- This allows the game to actually delete ents at a safe time
	EFL_DORMANT = (1 << 1),	// Entity is dormant, no updates to client
	EFL_NOCLIP_ACTIVE = (1 << 2),	// Lets us know when the noclip command is active.
	EFL_SETTING_UP_BONES = (1 << 3),	// Set while a model is setting up its bones.
	EFL_KEEP_ON_RECREATE_ENTITIES = (1 << 4), // This is a special entity that should not be deleted when we restart entities only

	EFL_HAS_PLAYER_CHILD = (1 << 4),	// One of the child entities is a player.

	EFL_DIRTY_SHADOWUPDATE = (1 << 5),	// Client only- need shadow manager to update the shadow...
	EFL_NOTIFY = (1 << 6),	// Another entity is watching events on this entity ( used by teleport )

	// The default behavior in ShouldTransmit is to not send an entity if it doesn't
	// have a model. Certain entities want to be sent anyway because all the drawing logic
	// is in the client DLL. They can set this flag and the engine will transmit them even
	// if they don't have a model.
	EFL_FORCE_CHECK_TRANSMIT = (1 << 7),

	EFL_BOT_FROZEN = (1 << 8),	// This is set on bots that are frozen.
	EFL_SERVER_ONLY = (1 << 9),	// Non-networked entity.
	EFL_NO_AUTO_EDICT_ATTACH = (1 << 10), // Don't attach the edict; we're doing it explicitly

	// Some dirty bits with respect to abs computations
	EFL_DIRTY_ABSTRANSFORM = (1 << 11),
	EFL_DIRTY_ABSVELOCITY = (1 << 12),
	EFL_DIRTY_ABSANGVELOCITY = (1 << 13),
	EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS = (1 << 14),
	EFL_DIRTY_SPATIAL_PARTITION = (1 << 15),
	EFL_DIRTY_PVS_INFORMATION = (1 << 16),

	EFL_IN_SKYBOX = (1 << 17),	// This is set if the entity detects that it's in the skybox.
	// This forces it to pass the "in PVS" for transmission.
	EFL_USE_PARTITION_WHEN_NOT_SOLID = (1 << 18),	// Entities with this flag set show up in the partition even when not solid
	EFL_TOUCHING_FLUID = (1 << 19),	// Used to determine if an entity is floating

	// FIXME: Not really sure where I should add this...
	EFL_IS_BEING_LIFTED_BY_BARNACLE = (1 << 20),
	EFL_NO_ROTORWASH_PUSH = (1 << 21),		// I shouldn't be pushed by the rotorwash
	EFL_NO_THINK_FUNCTION = (1 << 22),
	EFL_NO_GAME_PHYSICS_SIMULATION = (1 << 23),

	EFL_CHECK_UNTOUCH = (1 << 24),
	EFL_DONTBLOCKLOS = (1 << 25),		// I shouldn't block NPC line-of-sight
	EFL_DONTWALKON = (1 << 26),		// NPC;s should not walk on this entity
	EFL_NO_DISSOLVE = (1 << 27),		// These guys shouldn't dissolve
	EFL_NO_MEGAPHYSCANNON_RAGDOLL = (1 << 28),	// Mega physcannon can't ragdoll these guys.
	EFL_NO_WEAPON_PICKUP = (1 << 29),		// Characters can't pick up weapons
	EFL_NO_PHYSCANNON_INTERACTION = (1 << 30),	// Physcannon can't pick these up or punt them
	EFL_NO_DAMAGE_FORCES = (1 << 31),	// Doesn't accept forces from physics damage
};

struct C_IKContext {};

class virtualgroup_t
{
public:
	virtualgroup_t(void) { cache = NULL; };
	// tool dependant.  In engine this is a model_t, in tool it's a direct pointer
	void* cache;
	// converts cache entry into a usable studiohdr_t *
	__forceinline const studiohdr_t* GetStudioHdr(void) const {
		return g_csgo.m_model_cache->GetStudioHdr((studiohdr_t*)cache);
	}

	CUtlVector< int > boneMap;				// maps global bone to local bone
	CUtlVector< int > masterBone;			// maps local bone to global bone
	CUtlVector< int > masterSeq;			// maps local sequence to master sequence
	CUtlVector< int > masterAnim;			// maps local animation to master animation
	CUtlVector< int > masterAttachment;	// maps local attachment to global
	CUtlVector< int > masterPose;			// maps local pose parameter to global
	CUtlVector< int > masterNode;			// maps local transition nodes to global
};

class CThreadFastMutex {
public:
	volatile unsigned int m_ownerID;
	int				m_depth;
};

struct virtualsequence_t
{
	int	flags;
	int activity;
	int group;
	int index;
};

struct virtualgeneric_t
{
	int group;
	int index;
};

struct virtualmodel_t
{

	virtualgroup_t* pAnimGroup(int animation) { return &m_group[m_anim[animation].group]; }; // Note: user must manage mutex for this
	virtualgroup_t* pSeqGroup(int sequence) { return &m_group[m_seq[sequence].group]; }; // Note: user must manage mutex for this

	CThreadFastMutex m_Lock;

	CUtlVector< virtualsequence_t > m_seq;
	CUtlVector< virtualgeneric_t > m_anim;
	CUtlVector< virtualgeneric_t > m_attachment;
	CUtlVector< virtualgeneric_t > m_pose;
	CUtlVector< virtualgroup_t > m_group;
	CUtlVector< virtualgeneric_t > m_node;
	CUtlVector< virtualgeneric_t > m_iklock;
	CUtlVector< unsigned short > m_autoplaySequences;
};


struct mstudioseqdesc_t;
class CStudioHdr {
public:

	__forceinline int __thiscall GetNumSeq() {
		int v1;

		v1 = *(int*)(std::uintptr_t(this) + 4);
		if (v1)
			return *(int*)(std::uintptr_t(v1) + 20);
		else
			return *(int*)(std::uintptr_t(this) + 188);
	}

	__forceinline const studiohdr_t* GroupStudioHdr(int i)
	{
		if (!this)
		{
			return nullptr;
		}

		if (!m_pStudioHdrCache.Element(i))
		{
			const char* pszName;
			pszName = (m_pStudioHdr) ? m_pStudioHdr->m_name : "<<null>>";
			//ExecuteNTimes(5, Warning("Invalid index passed to CStudioHdr(%s)::GroupStudioHdr(): %d [%d]\n", pszName, i, m_pStudioHdrCache.Count()));
			//DebuggerBreakIfDebugging();
			return m_pStudioHdr; // return something known to probably exist, certainly things will be messed up, but hopefully not crash before the warning is noticed
		}

		const studiohdr_t* pStudioHdr = m_pStudioHdrCache[i];

		if (pStudioHdr == NULL)
		{
			virtualgroup_t* pGroup = &m_pVModel->m_group[i];
			pStudioHdr = pGroup->GetStudioHdr();
			m_pStudioHdrCache[i] = pStudioHdr;
		}
		return pStudioHdr;
	}

	/*__forceinline mstudioposeparamdesc_t& pPoseParameter(int i)
	{
		if (m_pVModel == NULL)
		{
			return *m_pStudioHdr->pLocalPoseParameter(i);
		}

		if (m_pVModel->m_pose[i].group == 0)
			return *m_pStudioHdr->pLocalPoseParameter(m_pVModel->m_pose[i].index);

		const studiohdr_t* pStudioHdr = GroupStudioHdr(m_pVModel->m_pose[i].group);

		return *pStudioHdr->pLocalPoseParameter(m_pVModel->m_pose[i].index);
	}*/


	studiohdr_t* m_pStudioHdr;
	virtualmodel_t* m_pVModel;
	PAD(0x4);
	CUtlVector<const studiohdr_t*> m_pStudioHdrCache; // 0x000C 
	int			                   m_nFrameUnlockCounter; // 0x0020 
	int* m_pFrameUnlockCounter; // 0x0024 
	PAD(0x8);
	CUtlVector<int>	               m_boneFlags; // 0x0030
	CUtlVector<int>	               m_boneParent; // 0x0050

	class CActivityToSequenceMapping /* final */
	{
	public:
		// A tuple of a sequence and its corresponding weight. Lists of these correspond to activities.
		struct SequenceTuple
		{
			short		seqnum;
			short		weight; // the absolute value of the weight from the sequence header
			uint16_t* pActivityModifiers;		// list of activity modifier symbols
			int			iNumActivityModifiers;
			int* iUnknown;
		};

		// The type of the hash's stored data, a composite of both key and value
		// (because that's how CUtlHash works):
		// key: an int, the activity #
		// values: an index into the m_pSequenceTuples array, a count of the
		// total sequences present for an activity, and the sum of their
		// weights.
		// Note this struct is 128-bits wide, exactly coincident to a PowerPC 
		// cache line and VMX register. Please consider very carefully the
		// performance implications before adding any additional fields to this.
		// You could probably do away with totalWeight if you really had to.
		struct HashValueType
		{
			// KEY (hashed)
			int activityIdx;

			// VALUE (not hashed)
			int startingIdx;
			int count;
			int totalWeight;

			HashValueType(int _actIdx, int _stIdx, int _ct, int _tW) :
				activityIdx(_actIdx), startingIdx(_stIdx), count(_ct), totalWeight(_tW) {}

			// default ConstructExor (ought not to be actually used)
			HashValueType() : activityIdx(-1), startingIdx(-1), count(-1), totalWeight(-1)
			{
				//AssertMsg(false, "Don't use default HashValueType()!");
			}


			class HashFuncs
			{
			public:
				// dummy ConstructExor (gndn)
				HashFuncs(int) {}

				// COMPARE
				// compare two entries for uniqueness. We should never have two different
				// entries for the same activity, so we only compare the activity index;
				// this allows us to use the utlhash as a dict by ConstructExing dummy entries
				// as hash lookup keys.
				/*bool operator()( const HashValueType& lhs, const HashValueType& rhs ) const
				{
					return lhs.activityIdx == rhs.activityIdx;
				}

				// HASH
				// We only hash on the activity index; everything else is data.
				unsigned int operator()( const HashValueType& item ) const
				{
					return HashInt( item.activityIdx );
				}*/
			};
		};

		//typedef CUtlHash<HashValueType, HashValueType::HashFuncs, HashValueType::HashFuncs> ActivityToValueIdxHash;

		// These must be here because IFM does not compile/link studio.cpp (?!?)

		// ctor
		CActivityToSequenceMapping(void)
			: m_pSequenceTuples(NULL), m_iSequenceTuplesCount(0), m_ActToSeqHash(8, 0, 0), m_pStudioHdr(NULL), m_expectedVModel(NULL)
		{};

		// dtor -- not virtual because this class has no inheritors
		~CActivityToSequenceMapping()
		{
			if (m_pSequenceTuples != NULL)
			{
				if (m_pSequenceTuples->pActivityModifiers != NULL)
				{
					delete[] m_pSequenceTuples->pActivityModifiers;
				}
				delete[] m_pSequenceTuples;
			}
		}

		/// Get the list of sequences for an activity. Returns the pointer to the
		/// first sequence tuple. Output parameters are a count of sequences present,
		/// and the total weight of all the sequences. (it would be more LHS-friendly
		/// to return these on registers, if only C++ offered more than one return 
		/// value....)
		/*const SequenceTuple* GetSequences( int forActivity, int* outSequenceCount, int* outTotalWeight );

		/// The number of sequences available for an activity.
		int NumSequencesForActivity( int forActivity );

		static CActivityToSequenceMapping* FindMapping( const CStudioHdr* pstudiohdr );
		static void ReleaseMapping( CActivityToSequenceMapping* pMap );
		static void ResetMappings( );

		//private:

			/// Allocate my internal array. (It is freed in the destructor.) Also,
			/// build the hash of activities to sequences and populate m_pSequenceTuples.
		void Initialize( const CStudioHdr* pstudiohdr );

		/// Force Initialize() to occur again, even if it has already occured.
		void Reinitialize( CStudioHdr* pstudiohdr );

		/// A more efficient version of the old SelectWeightedSequence() function in animation.cpp.
		int SelectWeightedSequence( CStudioHdr* pstudiohdr, int activity, int curSequence );

		// selects the sequence with the most matching modifiers
		int SelectWeightedSequenceFromModifiers( CStudioHdr* pstudiohdr, int activity, CUtlSymbol* pActivityModifiers, int iModifierCount, CBaseEntity* parent );*/

		// Actually a big array, into which the hash values index.
		SequenceTuple* m_pSequenceTuples;
		unsigned int m_iSequenceTuplesCount; // (size of the whole array)

		// we don't store an outer pointer because we can't initialize it at ConstructExion time
		// (warning c4355) -- there are ways around this but it's easier to just pass in a 
		// pointer to the CStudioHdr when we need it, since this class isn't supposed to 
		// export its interface outside the studio header anyway.
		// CStudioHdr * const m_pOuter;

		vec3_t m_ActToSeqHash;

		const studiohdr_t* m_pStudioHdr;

		// we store these so we can know if the contents of the studiohdr have changed
		// from underneath our feet (this is an emergency data integrity check)
		const void* m_expectedVModel;


		// double-check that the data I point to hasn't changed
		//bool ValidateAgainst( const CStudioHdr* __restrict pstudiohdr );
		//void SetValidation( const CStudioHdr* __restrict pstudiohdr );

		friend class CStudioHdr;
	};

	CActivityToSequenceMapping* m_pActivityToSequence;
};

class C_BoneMergeCache {
public:
	__forceinline void Init(void* owner) {
		static auto Init = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 8B 45 08 56 8B F1 89 06 C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C7 46 ? ? ? ? ? C6 86 ? ? ? ? ? C7 86 ? ? ? ? ? ? ? ? 83 BE")).as < void(__thiscall*)(void*, void*) >();
		Init(this, owner);
	}

	void* operator new (size_t size) {
		static auto C_BoneMergeCache__Constructor = pattern::find(g_csgo.m_client_dll, XOR("56 8B F1 0F 57 C0 C7 86 ?? ?? ?? ?? ?? ?? ?? ?? C7 86 ?? ?? ?? ?? ?? ?? ?? ?? C7 86")).as < void(__thiscall*)(void*) >();

		if (!C_BoneMergeCache__Constructor)
			return nullptr;

		auto* const ptr = static_cast<C_BoneMergeCache*>(g_csgo.m_mem_alloc->Alloc(676));
		if (!ptr)
			return nullptr;

		C_BoneMergeCache__Constructor(ptr);

		return ptr;
	}

	void operator delete(void* ptr) {
		g_csgo.m_mem_alloc->Free(ptr);
		ptr = nullptr;
	}

#ifdef CLIENT_DLL
	void MergeMatchingBones(int boneMask);
#else
	//void BuildMatricesWithBoneMerge ( const CStudioHdr *pStudioHdr, const QAngle &angles,
	//	const Vector &origin, const Vector pos [ MAXSTUDIOBONES ],
	//	const Quaternion q [ MAXSTUDIOBONES ], matrix3x4_t bonetoworld [ MAXSTUDIOBONES ],
	//	CBaseAnimating *pParent, CBoneCache *pParentCache, int boneMask );
#endif

	// CBoneMergeCache::CopyFromFollow (client.dll: "55 8B EC 83 EC 08 53 56 57 8B F9 89 7D F8 E8 ? ? ? ? 83 7F 10 00 0F 84 ? ? ? ? 8B 87 ? ? ? ? 85 C0 74 75")
	__forceinline void CopyFromFollow(vec3_t* followPos, quaternion_t* followQ, int boneMask, vec3_t myPos[256], quaternion_t myQ[256]) {
		static auto CopyFromFollow = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 83 EC 08 53 56 57 8B F9 89 7D F8 E8 ? ? ? ? 83 7F 10 00 0F 84 ? ? ? ? 8B 87 ? ? ? ? 85 C0 74 75")).as < void(__thiscall*)(void*, vec3_t*, quaternion_t*, int, vec3_t*, quaternion_t*) >();
		CopyFromFollow(this, followPos, followQ, boneMask, myPos, myQ);
	}

	__forceinline void UpdateCache() {
		static auto UpdateCache = pattern::find(g_csgo.m_client_dll, XOR("E8 ? ? ? ? 83 7E 10 00 74 64")).rel32(0x1).as<void(__thiscall*)(void*)>();
		UpdateCache(this);
	}

	// CBoneMergeCache::CopyToFollow (client.dll: "55 8B EC 83 EC 24 8B 45 08 57 8B F9 89 7D F4 85 C0 0F 84 ? ? ? ? 05 ? ? ? ? 53 56 89 45 EC")
	__forceinline void CopyToFollow(const vec3_t myPos[], const quaternion_t myQ[], int boneMask, vec3_t followPos[], quaternion_t followQ[]) {
		//static auto CopyToFollow = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 83 EC 24 8B 45 08 57 8B F9 89 7D F4 85 C0 0F 84 ? ? ? ? 05 ? ? ? ? 53 56 89 45 EC")).as < void(__thiscall*)(void*, vec3_t*, quaternion_t*, int, vec3_t*, quaternion_t*) >();
		//CopyToFollow(this, myPos, myQ, boneMask, followPos, followQ);
		UpdateCache();

		// If this is set, then all the other cache data is set.
		if (!m_pOwnerHdr || m_MergedBones.Count() == 0)
			return;

		// Now copy the bone matrices.
		for (int i = 0; i < m_MergedBones.Count(); i++)
		{
			int iOwnerBone = m_MergedBones[i].m_iMyBone;
			int iParentBone = m_MergedBones[i].m_iParentBone;

			// Only update bones reference by the bone mask.
			if (!(m_pOwnerHdr->m_boneFlags[iOwnerBone] & boneMask))
				continue;

			followPos[iParentBone] = myPos[iOwnerBone];
			followQ[iParentBone] = myQ[iOwnerBone];
		}
		m_nCopiedFramecount = g_csgo.m_globals->m_frame;

	}

	// CBoneMergeCache::MergeMatchingPoseParams (client.dll: "55 8B EC 83 EC 0C 53 56 8B F1 57 89 75 F8 E8 ? ? ? ? 83 7E 10 00 0F 84 ? ? ? ? 83 BE")
	__forceinline void MergeMatchingPoseParams() {
		static auto MergeMatchingPoseParams = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 83 EC 0C 53 56 8B F1 57 89 75 F8 E8 ? ? ? ? 83 7E 10 00 0F 84 ? ? ? ? 83 BE")).as < void(__thiscall*)(void*) >();
		MergeMatchingPoseParams(this);
	}
	//protected:
	void* m_pOwner;
	void* m_pFollow;
	CStudioHdr* m_pFollowHdr;
	const studiohdr_t* m_pFollowRenderHdr;
	CStudioHdr* m_pOwnerHdr;
	const studiohdr_t* m_pOwnerRenderHdr;
	int	m_nCopiedFramecount;
	int	m_nFollowBoneSetupMask;

	class CMergedBone {
	public:
		unsigned short m_iMyBone;
		unsigned short m_iParentBone;
	};

	int	m_nOwnerToFollowPoseParamMapping[24];
	CUtlVector< CMergedBone > m_MergedBones;
	PAD(12U);
	unsigned short m_iRawIndexMapping[138];
	bool m_bForceCacheClear;
};

class CIKContext;

enum ModelScaleType_t : int {
	HIERARCHICAL_MODEL_SCALE = 0,
	NONHIERARCHICAL_MODEL_SCALE
};

class Entity : public IClientUnknown {
public:
	// helper methods.
	template< typename t >
	__forceinline t& get(size_t offset) {
		return *(t*)((uintptr_t)this + offset);
	}

	template< typename t >
	__forceinline void set(size_t offset, const t& val) {
		*(t*)((uintptr_t)this + offset) = val;
	}

	template< typename t >
	__forceinline t as() {
		return (t)this;
	}

public:
	// netvars / etc.
	__forceinline vec3_t& m_vecOrigin() {
		return get< vec3_t >(g_entoffsets.m_vecOrigin);
	}

	__forceinline int& m_nSmokeEffectTickBegin() {
		return get< int >(g_entoffsets.m_nSmokeEffectTickBegin);

	}

	__forceinline float& m_flSpawnTime_Grenade()
	{
		return get< float >(g_entoffsets.m_flSpawnTime_Grenade);
	}

	__forceinline EHANDLE& m_hThrower()
	{
		return get< EHANDLE >(g_entoffsets.m_hThrower);
	}

	__forceinline vec3_t& m_vecOldOrigin() {
		return get< vec3_t >(g_entoffsets.m_vecOldOrigin);
	}

	__forceinline vec3_t& m_vecBaseVelocity() {
		return get< vec3_t >(g_entoffsets.m_vecBaseVelocity);
	}

	__forceinline float& m_flFallVelocity() {
		return get< float >(g_entoffsets.m_flFallVelocity);
	}

	__forceinline float& m_flDuckSpeed() {
		return get< float >(g_entoffsets.m_flDuckSpeed);
	}

	__forceinline vec3_t& m_vecLadderNormal() {
		return get< vec3_t >(g_entoffsets.m_vecLadderNormal);
	}

	__forceinline float& m_flStamina() {
		return get< float >(g_entoffsets.m_flStamina);
	}

	__forceinline bool& m_bStrafing() {
		return get< bool >(g_entoffsets.m_bStrafing);
	}

	__forceinline bool& m_bDucked() {
		return get< bool >(g_entoffsets.m_bDucked);
	}

	__forceinline int& m_ScaleType() {
		return get< int >(g_entoffsets.m_ScaleType);
	}

	__forceinline float& m_flEncodedController() {
		return get < float >(g_entoffsets.m_flEncodedController);
	}

	__forceinline float GetModelHierarchyScale() {
		if (this->m_ScaleType() == HIERARCHICAL_MODEL_SCALE)
			return this->m_flModelScale();

		const CStudioHdr* pStudioHdr = this->GetModelPtr();
		return (pStudioHdr != nullptr && pStudioHdr->m_pStudioHdr->m_num_bones == 1) ? this->m_flModelScale() : 1.0f;
	}

	__forceinline matrix3x4_t& m_hCoordFrame() {
		return get< matrix3x4_t >(g_entoffsets.coordinate_frame);
	}

	__forceinline bool m_bDuckUntilOnGround() {
		return *(bool*)((DWORD)(this) + 0x10432);
	}

	__forceinline float& m_fAccuracyPenalty() {
		return get< float >(g_entoffsets.m_fAccuracyPenalty);
	}

	__forceinline vec3_t& m_vecVelocity() {
		return get< vec3_t >(g_entoffsets.m_vecVelocity);
	}

	__forceinline vec3_t& m_vecMins() {
		return get< vec3_t >(g_entoffsets.m_vecMins);
	}

	__forceinline int& m_nSequenceViewmodel() {
		return get< int >(g_entoffsets.m_nSequenceViewmodel);
	}

	__forceinline matrix3x4_t& m_pCoordFrame() {
		return get< matrix3x4_t >(g_entoffsets.m_pCoordFrame);
	}

	__forceinline vec3_t& m_vecMaxs() {
		return get< vec3_t >(g_entoffsets.m_vecMaxs);
	}

	__forceinline int& m_iTeamNum() {
		return get< int >(g_entoffsets.m_iTeamNum);
	}

	__forceinline int& m_nSequence() {
		return get< int >(g_entoffsets.m_nSequence);
	}

	__forceinline float& m_flCycle() {
		return get< float >(g_entoffsets.m_flCycle);
	}

	__forceinline float& m_flC4Blow() {
		return get< float >(g_entoffsets.m_flC4Blow);
	}

	__forceinline bool& m_bBombTicking() {
		return get< bool >(g_entoffsets.m_bBombTicking);
	}

	__forceinline int& m_fEffects() {
		// todo; netvar.
		return get< int >(g_entoffsets.m_fEffects);
	}


	__forceinline uint32_t& m_hViewModel() {
		return get< uint32_t >(g_entoffsets.m_hViewModel);
	}

	__forceinline int& m_nAnimationParity() {
		return get< int >(g_entoffsets.m_nAnimationParity);
	}

	__forceinline float& m_flAnimTime() {
		return get< float >(g_entoffsets.m_flAnimTime);
	}

	__forceinline C_IKContext*& m_pIKContext() {
		return *reinterpret_cast<C_IKContext**>(reinterpret_cast<uintptr_t>(this) + (g_entoffsets.m_nForceBone - 0x1C));
	}

	__forceinline int& m_nLastNonSkippedFrame() {
		return *(int*)(uintptr_t(this) + 0xA68);
	}

	__forceinline int& m_nCustomBlendingRuleMask() {
		return *(int*)(uintptr_t(this) + 0xA24);
	}

	__forceinline int& m_nAnimLODflags() {
		return *(int*)(uintptr_t(this) + 0xA28);
	}

	__forceinline int& occlusion_flags() {
		return *reinterpret_cast<int*>(
			reinterpret_cast<std::uintptr_t>(this) + 0xa28
			);
	}

	__forceinline int& occlusion_frame() {
		return *reinterpret_cast<int*>(
			reinterpret_cast<std::uintptr_t>(this) + 0xa30
			);
	}

	__forceinline int& ent_client_flags() {
		return *reinterpret_cast<int*>(
			reinterpret_cast<std::uintptr_t>(this) + 0x68u
			);
	}

	__forceinline int& last_setup_bones_frame() {
		return *reinterpret_cast<int*>(
			reinterpret_cast<std::uintptr_t>(this) + 0xa68u
			);
	}

	__forceinline float& last_setup_bones_time() {
		return *reinterpret_cast<float*>(
			reinterpret_cast<std::uintptr_t>(this) + 0x2928u
			);
	}

	__forceinline unsigned long& mdl_bone_counter() {
		return *reinterpret_cast<unsigned long*>(
			reinterpret_cast<std::uintptr_t>(this) + 0x2690u
			);
	}

	//__forceinline void update_visibility_all_entities()
	//{
	//	static uintptr_t* update_visibility_all_entities = nullptr;
	//	if (update_visibility_all_entities == nullptr) {
	//
	//		static std::uintptr_t call_insctruction = g_cl.m>addresses().m_upd_visb_entities;
	//		static DWORD rel_add = *(DWORD*)(call_insctruction + 1);
	//		static DWORD next_instruction = call_insctruction + 5;
	//		update_visibility_all_entities = (uintptr_t*)(next_instruction + rel_add);
	//
	//	}
	//	else
	//		reinterpret_cast<void(__thiscall*)(void*)> (update_visibility_all_entities)(this);
	//}

	__forceinline  int& m_ClientEntEffects() {
		return *(int*)(uintptr_t(this) + 0x68);
	}
	
	__forceinline float& m_flModelScale() {
		return get< float >(g_entoffsets.m_flModelScale);
	}

	__forceinline CIKContext*& m_pIK() {
		return *(CIKContext**)(uintptr_t(this) + (g_entoffsets.m_nForceBone - 0x1C));
	}

	__forceinline int& ik_context() {
		return *(int*)(this + 0x2570);
	}

	__forceinline bool GameSetupBones(matrix3x4_t* out, int max, int mask, float time) {
		return util::get_method< bool(__thiscall*)(void*, matrix3x4_t*, int, int, float)>(renderable(), 13)(renderable(), out, max, mask, time);
	}

	__forceinline float& v107() {
		return get< float >(0x3ad0 + 0x4);
	}

	__forceinline float& v108() {
		return get< float >(0x6f20 + 0x4);
	}


	__forceinline int& m_iPrevBoneMask() {
		return *(int*)(uintptr_t(this) + (g_entoffsets.m_nForceBone + 0x10));
	}

	__forceinline int& m_iAccumulatedBoneMask() {
		return *(int*)(uintptr_t(this) + (g_entoffsets.m_nForceBone + 0x14));
	}

	__forceinline int& m_iOcclusionFramecount() {
		return *(int*)(uintptr_t(this) + (0xA30));
	}

	__forceinline int& m_iOcclusionFlags() {
		return *(int*)(uintptr_t(this) + (0xA28));
	}

	__forceinline int& m_nModelIndex() {
		return get< int >(g_entoffsets.m_nModelIndex);
	}

	__forceinline bool& m_bReadyToDraw() {
		return get< bool >(g_entoffsets.m_bReadyToDraw);
	}

	__forceinline int& m_vphysicsCollisionState() {
		return get< int >(g_entoffsets.m_vphysicsCollisionState);
	}

	__forceinline float& m_SpawnTime() {
		return get< float >(g_entoffsets.m_SpawnTime);
	}

	__forceinline auto& m_fireCount() {
		return get< int >(g_entoffsets.m_SpawnTime);
	}

	__forceinline CStudioHdr* m_studioHdr() {
		// .text:1017E902 08C    8B 86 3C 29 00 00    mov     eax, [ esi + 293Ch ]
		// .text:1017E908 08C    89 44 24 10          mov[ esp + 88h + var_78 ], eax
		return get< CStudioHdr* >(g_csgo.studioHdr);
	}

	__forceinline CStudioHdr* GetModelPtr() {
		using LockStudioHdr_t = void(__thiscall*)(decltype(this));

		if (!m_studioHdr())
			g_csgo.LockStudioHdr.as< LockStudioHdr_t >()(this);

		return m_studioHdr();
	}

	void UpdateAnimationState(CCSGOPlayerAnimState* state, vec3_t angle)
	{
		static auto UpdateAnimState = pattern::find(g_csgo.m_client_dll, "55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24");
		if (!UpdateAnimState)
			return;

		__asm
		{
			mov ecx, state

			movss xmm1, dword ptr[angle + 4]
			movss xmm2, dword ptr[angle]

			call UpdateAnimState
		}
	}

public:
	// virtual indices
	enum indices : size_t {
		WORLDSPACECENTER = 78,
		GETMAXHEALTH = 122,
		ISPLAYER = 152,
		ISBASECOMBATWEAPON = 160,
	};

public:
	// virtuals.
	// renderable table.
	__forceinline void* renderable() {
		return (void*)((uintptr_t)this + 0x4);
	}

	__forceinline vec3_t& GetRenderOrigin() {
		return util::get_method< vec3_t & (__thiscall*)(void*) >(renderable(), 1)(renderable());
	}

	__forceinline ang_t& GetRenderAngles() {
		return util::get_method< ang_t & (__thiscall*)(void*) >(renderable(), 2)(renderable());
	}

	__forceinline const model_t* GetModel() {
		return util::get_method< const model_t * (__thiscall*)(void*) >(renderable(), 8)(renderable());
	}

	__forceinline void DrawModel(int flags = STUDIO_RENDER, const RenderableInstance_t& instance = {}) {
		return util::get_method< void(__thiscall*)(void*, int, const RenderableInstance_t&)>(renderable(), 9)(renderable(), flags, instance);
	}

	datamap_t* GetDataDescMap() {
		typedef datamap_t* (__thiscall* o_GetDataDescMap)(void*);
		return util::get_method<o_GetDataDescMap>(this, 15)(this);
	}

	datamap_t* GetPredDescMap() {
		typedef datamap_t* (__thiscall* o_GetPredDescMap)(void*);
		return util::get_method<o_GetPredDescMap>(this, 17)(this);
	}

	__forceinline bool SetupBones(matrix3x4_t* out, int max, int mask, float time) {
		return util::get_method< bool(__thiscall*)(void*, matrix3x4_t*, int, int, float)>(renderable(), 13)(renderable(), out, max, mask, time);
	}

	// networkable table.
	__forceinline void* networkable() {
		return (void*)((uintptr_t)this + 0x8);
	}

	__forceinline void Release() {
		return util::get_method< void(__thiscall*)(void*) >(networkable(), 1)(networkable());
	}

	__forceinline ClientClass* GetClientClass() {
		return util::get_method< ClientClass * (__thiscall*)(void*) >(networkable(), 2)(networkable());
	}

	__forceinline void OnDataChanged(DataUpdateType_t type) {
		return util::get_method< void(__thiscall*)(void*, DataUpdateType_t) >(networkable(), 5)(networkable(), type);
	}

	__forceinline void PreDataUpdate(DataUpdateType_t type) {
		return util::get_method< void(__thiscall*)(void*, DataUpdateType_t) >(networkable(), 6)(networkable(), type);
	}

	__forceinline void PostDataUpdate(DataUpdateType_t type) {
		return util::get_method< void(__thiscall*)(void*, DataUpdateType_t) >(networkable(), 7)(networkable(), type);
	}

	__forceinline bool dormant() {
		return util::get_method< bool(__thiscall*)(void*) >(networkable(), 9)(networkable());
	}

	__forceinline int index() {
		return util::get_method< int(__thiscall*)(void*) >(networkable(), 10)(networkable());
	}

	__forceinline void SetDestroyedOnRecreateEntities() {
		return util::get_method< void(__thiscall*)(void*) >(networkable(), 13)(networkable());
	}

	// normal table.
	__forceinline const vec3_t& GetAbsOrigin() {
		return util::get_method< const vec3_t & (__thiscall*)(void*) >(this, 10)(this);
	}

	__forceinline const ang_t& GetAbsAngles() {
		return util::get_method< const ang_t & (__thiscall*)(void*) >(this, 11)(this);
	}

	__forceinline bool IsPlayer() {
		return util::get_method< bool(__thiscall*)(void*) >(this, ISPLAYER)(this);
	}

	__forceinline bool IsBaseCombatWeapon() {
		return util::get_method< bool(__thiscall*)(void*) >(this, ISBASECOMBATWEAPON)(this);
	}

	__forceinline std::string GetBombsiteName() {
		std::string out;

		// note - dex; bomb_target + 0x150 has a char array for site name... not sure how much memory gets allocated for it.
		out.resize(32u);

		std::memcpy(&out[0], (const void*)((uintptr_t)this + 0x150), 32u);

		return out;
	}

	__forceinline vec3_t GetBonePosition(int iBone)
	{
		matrix3x4_t boneMatrixes[128];
		if (this->SetupBones(boneMatrixes, 128, 0x100, 0))
		{
			matrix3x4_t boneMatrix = boneMatrixes[iBone];
			return vec3_t(boneMatrix.m_flMatVal[0][3], boneMatrix.m_flMatVal[1][3], boneMatrix.m_flMatVal[2][3]);
		}
		else
			return vec3_t(0, 0, 0);
	}

	__forceinline void InvalidatePhysicsRecursive(int32_t flags) {
		using InvalidatePhysicsRecursive_t = void(__thiscall*)(decltype(this), int32_t);
		g_csgo.InvalidatePhysicsRecursive.as< InvalidatePhysicsRecursive_t >()(this, flags);
	}

	__forceinline void SetAbsAngles(const ang_t& angles) {
		using SetAbsAngles_t = void(__thiscall*)(decltype(this), const ang_t&);
		g_csgo.SetAbsAngles.as< SetAbsAngles_t >()(this, angles);
	}

	__forceinline void SetAbsOrigin(const vec3_t& origin) {
		using SetAbsOrigin_t = void(__thiscall*)(decltype(this), const vec3_t&);
		g_csgo.SetAbsOrigin.as< SetAbsOrigin_t >()(this, origin);
	}

	__forceinline void SetAbsVelocity(const vec3_t& velocity) {
		using SetAbsVelocity_t = void(__thiscall*)(decltype(this), const vec3_t&);
		g_csgo.SetAbsVelocity.as< SetAbsVelocity_t >()(this, velocity);
	}

	__forceinline void ApplyVelocity(const vec3_t& velocity) {
		m_vecVelocity() = velocity;
		SetAbsVelocity(velocity);
	}

	__forceinline void AddEffect(int effects) {
		m_fEffects() |= effects;
	}


	__forceinline void RemoveEffect(int effects) {
		m_fEffects() &= ~effects;
	}

	__forceinline int get_class_id() {
		ClientClass* cc{ GetClientClass() };

		return (cc) ? cc->m_ClassID : -1;
	}

	__forceinline bool is(hash32_t hash) {
		return g_netvars.GetClientID(hash) == get_class_id();
	}

	__forceinline float* m_flPoseParameter() {
		return (float*)((uintptr_t)this + g_entoffsets.m_flPoseParameter);
	}

	__forceinline C_BoneMergeCache*& m_pBoneMergeCache() {
		return *(C_BoneMergeCache**)((uintptr_t)this + 0x28FC);
	}

	__forceinline int LookupPoseParameter(CStudioHdr* pStudioHdr, const char* szName)
	{
		if (!pStudioHdr)
			return 0;

		// 55 8B EC 57 8B 7D 08 85 FF 75 08
		static auto func = pattern::find(g_csgo.m_client_dll, "55 8B EC 57 8B 7D 08 85 FF 75 08").as<int(__stdcall*)(CStudioHdr*, const char*)>();

		if (!func) {
			MessageBoxA(NULL, "Womp Womp", "Error", MB_OK | MB_ICONEXCLAMATION);
			return -1;
		}

		return func(pStudioHdr, szName);
	}

	float& GetCreationTime();
};

class some_ptr_t {};

class CStudioHdrEx {
public:
	studiohdr_t* studio_hdr;
	void* virtual_model;
	char pad[120];

	int m_nPerfAnimatedBones;
	int m_nPerfUsedBones;
	int m_nPerfAnimationLayers;
};

enum EAnimationStatePoseParameters : int
{
	PLAYER_POSE_PARAM_FIRST = 0,
	PLAYER_POSE_PARAM_LEAN_YAW = PLAYER_POSE_PARAM_FIRST,
	PLAYER_POSE_PARAM_SPEED,
	PLAYER_POSE_PARAM_LADDER_SPEED,
	PLAYER_POSE_PARAM_LADDER_YAW,
	PLAYER_POSE_PARAM_MOVE_YAW,
	PLAYER_POSE_PARAM_RUN,
	PLAYER_POSE_PARAM_BODY_YAW,
	PLAYER_POSE_PARAM_BODY_PITCH,
	PLAYER_POSE_PARAM_DEATH_YAW,
	PLAYER_POSE_PARAM_STAND,
	PLAYER_POSE_PARAM_JUMP_FALL,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_IDLE,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_IDLE,
	PLAYER_POSE_PARAM_STRAFE_DIR,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_WALK,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_RUN,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_RUN,
	PLAYER_POSE_PARAM_MOVE_BLEND_CROUCH_WALK,
	//PLAYER_POSE_PARAM_STRAFE_CROSS,
	PLAYER_POSE_PARAM_COUNT
};

enum PoseParam_t {
	POSE_STRAFE_YAW,
	POSE_STAND,
	POSE_LEAN_YAW,
	POSE_SPEED,
	POSE_LADDER_YAW,
	POSE_LADDER_SPEED,
	POSE_JUMP_FALL,
	POSE_MOVE_YAW,
	POSE_MOVE_BLEND_CROUCH,
	POSE_MOVE_BLEND_WALK,
	POSE_MOVE_BLEND_RUN,
	POSE_BODY_YAW,
	POSE_BODY_PITCH,
	POSE_AIM_BLEND_STAND_IDLE,
	POSE_AIM_BLEND_STAND_WALK,
	POSE_AIM_BLEND_STAND_RUN,
	POSE_AIM_BLEND_COURCH_IDLE,
	POSE_AIM_BLEND_CROUCH_WALK,
	POSE_DEATH_YAW
};

class C_AnimationLayer {
	//change later
public:
	bool		client_blend{};
	float		blend_in{};
	void* studio_hdr{};

	int			dispatch_sequence{};
	int			second_dispatch_sequence{};

	uint32_t	order{};
	uint32_t	sequence{};

	float		prev_cycle{};
	float		weight{};
	float		weight_delta_rate{};
	float		playback_rate{};
	float		cycle{};

	void* owner{};

	PAD(4);
}; // size: 0x0038

enum animtag_indices
{
	ANIMTAG_INVALID = -1,
	ANIMTAG_UNINITIALIZED = 0,
	ANIMTAG_STARTCYCLE_N,
	ANIMTAG_STARTCYCLE_NE,
	ANIMTAG_STARTCYCLE_E,
	ANIMTAG_STARTCYCLE_SE,
	ANIMTAG_STARTCYCLE_S,
	ANIMTAG_STARTCYCLE_SW,
	ANIMTAG_STARTCYCLE_W,
	ANIMTAG_STARTCYCLE_NW,
	ANIMTAG_AIMLIMIT_YAWMIN_IDLE,
	ANIMTAG_AIMLIMIT_YAWMAX_IDLE,
	ANIMTAG_AIMLIMIT_YAWMIN_WALK,
	ANIMTAG_AIMLIMIT_YAWMAX_WALK,
	ANIMTAG_AIMLIMIT_YAWMIN_RUN,
	ANIMTAG_AIMLIMIT_YAWMAX_RUN,
	ANIMTAG_AIMLIMIT_YAWMIN_CROUCHIDLE,
	ANIMTAG_AIMLIMIT_YAWMAX_CROUCHIDLE,
	ANIMTAG_AIMLIMIT_YAWMIN_CROUCHWALK,
	ANIMTAG_AIMLIMIT_YAWMAX_CROUCHWALK,
	ANIMTAG_AIMLIMIT_PITCHMIN_IDLE,
	ANIMTAG_AIMLIMIT_PITCHMAX_IDLE,
	ANIMTAG_AIMLIMIT_PITCHMIN_WALKRUN,
	ANIMTAG_AIMLIMIT_PITCHMAX_WALKRUN,
	ANIMTAG_AIMLIMIT_PITCHMIN_CROUCH,
	ANIMTAG_AIMLIMIT_PITCHMAX_CROUCH,
	ANIMTAG_AIMLIMIT_PITCHMIN_CROUCHWALK,
	ANIMTAG_AIMLIMIT_PITCHMAX_CROUCHWALK,
	ANIMTAG_WEAPON_POSTLAYER,
	ANIMTAG_FLASHBANG_PASSABLE,
	ANIMTAG_COUNT
};

struct mstudioactivitymodifier_t
{
	int					sznameindex;
	inline char* pszName() { return (sznameindex) ? (char*)(((byte*)this) + sznameindex) : NULL; }
};

struct animtaglookup_t
{
	int nIndex;
	const char* szName;
};

#define REGISTER_ANIMTAG( _n ) { _n, #_n },
const animtaglookup_t animtag_lookup_table[ANIMTAG_COUNT] =
{
	REGISTER_ANIMTAG(ANIMTAG_UNINITIALIZED)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_N)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_NE)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_E)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_SE)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_S)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_SW)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_W)
	REGISTER_ANIMTAG(ANIMTAG_STARTCYCLE_NW)

	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMIN_IDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMAX_IDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMIN_WALK)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMAX_WALK)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMIN_RUN)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMAX_RUN)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMIN_CROUCHIDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMAX_CROUCHIDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMIN_CROUCHWALK)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_YAWMAX_CROUCHWALK)

	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMIN_IDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMAX_IDLE)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMIN_WALKRUN)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMAX_WALKRUN)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMIN_CROUCH)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMAX_CROUCH)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMIN_CROUCHWALK)
	REGISTER_ANIMTAG(ANIMTAG_AIMLIMIT_PITCHMAX_CROUCHWALK)

	REGISTER_ANIMTAG(ANIMTAG_FLASHBANG_PASSABLE)

	REGISTER_ANIMTAG(ANIMTAG_WEAPON_POSTLAYER)
};

struct studioanimtag_t {
	int					tag;
	float				cycle;

	int					sztagindex;
	inline char* const TagName(void) const { return ((char*)this) + sztagindex; }

	inline int IndexFromAnimTagName(const char* szName) {
		int i;
		for (i = 1; i < ANIMTAG_COUNT; i++)
		{
			const animtaglookup_t* pAnimTag = &animtag_lookup_table[i];
			if (!strcmp(szName, pAnimTag->szName))
			{
				return pAnimTag->nIndex;
			}
		}
		return ANIMTAG_INVALID;
	}
};

struct mstudioseqdesc_t {
	int					base_ptr;
	int					szlabel_index;
	int					szactivity_name_index;
	int					flags;		// looping/non-looping flags
	int					activity;	// initialized at loadtime to game DLL values
	int					act_weight;
	int					num_events;
	int					event_index;
	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;
	int					numblends;
	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int					anim_index_index;
	int					movement_index;	// [blend] float array for blended movement
	int					groupsize[2];
	int					param_index[2];	// X, Y, Z, XR, YR, ZR
	float				param_start[2];	// local (0..1) starting value
	float				param_end[2];	// local (0..1) ending value
	int					param_parent;
	float				fade_in_time;		// ideal cross fate in time (0.2 default)
	float				fade_out_time;	// ideal cross fade out time (0.2 default)
	int					local_entry_node;		// transition node at entry
	int					local_exit_node;		// transition node at exit
	int					node_flags;		// transition rules
	float				entry_phase;		// used to match entry gait
	float				exit_phase;		// used to match exit gait
	float				last_frame;		// frame that should generation EndOfSequence
	int					next_seq;		// auto advancing sequences
	int					pose;			// index of delta animation between end and nextseq
	int					num_ik_rules;
	int					num_auto_layers;	//
	int					auto_layer_index;
	int					weight_list_index;
	// FIXME: make this 2D instead of 2x1D arrays
	int					pose_key_index;
	int					num_ik_locks;
	int					ik_lock_index;
	// Key values
	int					key_value_index;
	int					key_value_size;
	int					cycle_pose_index;		// index of pose parameter to use as cycle index
	int					activity_modifier_index;
	int					num_activity_modifiers;
	int					anim_tag_index;
	int					num_anim_tags;
	int					root_driver_index;
	int					unused[2];		// remove/add as appropriate (grow back to 8 ints on version change!)
	inline mstudioactivitymodifier_t* pActivityModifier(int i) const { assert(i >= 0 && i < num_activity_modifiers); return activity_modifier_index != 0 ? (mstudioactivitymodifier_t*)(((byte*)this) + activity_modifier_index) + i : NULL; };
	inline studioanimtag_t* GetAnimTag(int i) const { assert(i >= 0 && i < num_anim_tags); return (studioanimtag_t*)(((byte*)this) + anim_tag_index) + i; };
};

class CBoneAccessor {
public:
	void* m_pAnimating;
	matrix3x4_t* m_pBones;
	int        m_ReadableBones;
	int        m_WritableBones;
};

class CBoneCache {
public:
	matrix3x4_t* m_pCachedBones;
	PAD(0x8);
	int        m_CachedBoneCount;
};

class Ragdoll : public Entity {
public:
	__forceinline Player* GetPlayer() {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Player* >(m_hPlayer());
	}

	__forceinline EHANDLE& m_hPlayer() {
		return get< EHANDLE >(g_entoffsets.m_hPlayer);
	}

	__forceinline float& m_flDeathYaw() {
		return get< float >(g_entoffsets.m_flDeathYaw);
	}

	__forceinline float& m_flAbsYaw() {
		return get< float >(g_entoffsets.m_flAbsYaw);
	}
};

class CPlayerState {
public:
	virtual ~CPlayerState() { }
	bool deadflag;
	ang_t		v_angle; // Viewing angle (player only)
};

struct aimmatrix_transition_t
{
	float	m_flDurationStateHasBeenValid;
	float	m_flDurationStateHasBeenInValid;
	float	m_flHowLongToWaitUntilTransitionCanBlendIn;
	float	m_flHowLongToWaitUntilTransitionCanBlendOut;
	float	m_flBlendValue;

	void UpdateTransitionState(bool bStateShouldBeValid, float flTimeInterval, float flSpeed)
	{
		if (bStateShouldBeValid)
		{
			m_flDurationStateHasBeenInValid = 0;
			m_flDurationStateHasBeenValid += flTimeInterval;
			if (m_flDurationStateHasBeenValid >= m_flHowLongToWaitUntilTransitionCanBlendIn)
			{
				m_flBlendValue = math::Approach(1, m_flBlendValue, flSpeed);
			}
		}
		else
		{
			m_flDurationStateHasBeenValid = 0;
			m_flDurationStateHasBeenInValid += flTimeInterval;
			if (m_flDurationStateHasBeenInValid >= m_flHowLongToWaitUntilTransitionCanBlendOut)
			{
				m_flBlendValue = math::Approach(0, m_flBlendValue, flSpeed);
			}
		}
	}

	void Init(void) {
		m_flDurationStateHasBeenValid = 0;
		m_flDurationStateHasBeenInValid = 0;
		m_flHowLongToWaitUntilTransitionCanBlendIn = 0.3f;
		m_flHowLongToWaitUntilTransitionCanBlendOut = 0.3f;
		m_flBlendValue = 0;
	}

	aimmatrix_transition_t() {
		Init();
	}
};

struct procedural_foot_t {
	vec3_t m_vecPosAnim;
	vec3_t m_vecPosAnimLast;
	vec3_t m_vecPosPlant;
	vec3_t m_vecPlantVel;
	float m_flLockAmount;
	float m_flLastPlantTime;
};

#define ANIM_LAYER_ACTIVE		0x0001
#define ANIM_LAYER_AUTOKILL		0x0002
#define ANIM_LAYER_KILLME		0x0004
#define ANIM_LAYER_DONTRESTORE	0x0008
#define ANIM_LAYER_CHECKACCESS	0x0010
#define ANIM_LAYER_DYING		0x0020
#define ANIM_LAYER_NOEVENTS		0x0040


struct animstate_pose_param_cache_t {
	bool m_bInitialized;
	int	m_nIndex;
	const char* m_szName;

	bool Init(Entity* pPlayer, const char* szPoseParamName) {
		g_csgo.m_model_cache->BeginLock();
		m_szName = szPoseParamName;
		m_nIndex = pPlayer->LookupPoseParameter(pPlayer->m_studioHdr(), szPoseParamName);
		if (m_nIndex != -1) {
			m_bInitialized = true;
		}
		g_csgo.m_model_cache->EndLock();

		return m_bInitialized;
	}

	void SetValue(Player* player, float flValue);
};

enum
{
	PLAYERANIMEVENT_FIRE_GUN_PRIMARY = 0,
	PLAYERANIMEVENT_FIRE_GUN_PRIMARY_OPT, // an optional primary attack for variation in animation. For example, the knife toggles between left AND right slash animations.
	PLAYERANIMEVENT_FIRE_GUN_PRIMARY_SPECIAL1,
	PLAYERANIMEVENT_FIRE_GUN_PRIMARY_OPT_SPECIAL1, // an optional primary special attack for variation in animation.
	PLAYERANIMEVENT_FIRE_GUN_SECONDARY,
	PLAYERANIMEVENT_FIRE_GUN_SECONDARY_SPECIAL1,
	PLAYERANIMEVENT_GRENADE_PULL_PIN,
	PLAYERANIMEVENT_THROW_GRENADE,
	PLAYERANIMEVENT_JUMP,
	PLAYERANIMEVENT_RELOAD,
	PLAYERANIMEVENT_RELOAD_START,	///< w_model partial reload for shotguns
	PLAYERANIMEVENT_RELOAD_LOOP,	///< w_model partial reload for shotguns
	PLAYERANIMEVENT_RELOAD_END,		///< w_model partial reload for shotguns
	PLAYERANIMEVENT_CLEAR_FIRING,	///< clear animations on the firing layer
	PLAYERANIMEVENT_DEPLOY,			///< Used to play deploy animations on third person models.
	PLAYERANIMEVENT_SILENCER_ATTACH,
	PLAYERANIMEVENT_SILENCER_DETACH,

	// new events
	PLAYERANIMEVENT_THROW_GRENADE_UNDERHAND,
	PLAYERANIMEVENT_CATCH_WEAPON,
	PLAYERANIMEVENT_COUNT
};

class CCSGOPlayerAnimState {
public:
	const int* m_pLayerOrderPreset;
	bool m_bFirstRunSinceInit;
	bool m_bFirstFootPlantSinceInit;
	int m_iLastUpdateFrame;
	float m_flEyePositionSmoothLerp;
	float m_flStrafeChangeWeightSmoothFalloff;
	aimmatrix_transition_t m_tStandWalkAim;
	aimmatrix_transition_t m_tStandRunAim;
	aimmatrix_transition_t m_tCrouchWalkAim;
	int m_cachedModelIndex;
	float m_flStepHeightLeft;
	float m_flStepHeightRight;
	Weapon* m_pWeaponLastBoneSetup;
	Player* m_pPlayer;
	Weapon* m_pWeapon;
	Weapon* m_pWeaponLast;
	float m_flLastUpdateTime;
	int m_nLastUpdateFrame;
	float m_flLastUpdateIncrement;
	float m_flEyeYaw;
	float m_flEyePitch;
	float m_flFootYaw;
	float m_flFootYawLast;
	float m_flMoveYaw;
	float m_flMoveYawIdeal;
	float m_flMoveYawCurrentToIdeal;
	float m_flTimeToAlignLowerBody;
	float m_flPrimaryCycle;
	float m_flMoveWeight;
	float m_flMoveWeightSmoothed;
	float m_flAnimDuckAmount;
	float m_flDuckAdditional;
	float m_flRecrouchWeight;
	vec3_t	m_vecPositionCurrent;
	vec3_t	m_vecPositionLast;
	vec3_t	m_vecVelocity;
	vec3_t	m_vecVelocityNormalized;
	vec3_t	m_vecVelocityNormalizedNonZero;
	float m_flVelocityLengthXY;
	float m_flVelocityLengthZ;
	float m_flSpeedAsPortionOfRunTopSpeed;
	float m_flSpeedAsPortionOfWalkTopSpeed;
	float m_flSpeedAsPortionOfCrouchTopSpeed;
	float m_flDurationMoving;
	float m_flDurationStill;
	bool m_bOnGround;
	bool m_bLanding;
	float m_flJumpToFall;
	float m_flDurationInAir;
	float m_flLeftGroundHeight;
	float m_flLandAnimMultiplier;
	float m_flWalkToRunTransition;
	bool m_bLandedOnGroundThisFrame;
	bool m_bLeftTheGroundThisFrame;
	float m_flInAirSmoothValue;
	bool m_bOnLadder;
	float m_flLadderWeight;
	float m_flLadderSpeed;
	bool m_bWalkToRunTransitionState;
	bool m_bDefuseStarted;
	bool m_bPlantAnimStarted;
	bool m_bTwitchAnimStarted;
	bool m_bAdjustStarted;
	CUtlVector< uint16_t > m_ActivityModifiers;
	float m_flNextTwitchTime;
	float m_flTimeOfLastKnownInjury;
	float m_flLastVelocityTestTime;
	vec3_t m_vecVelocityLast;
	vec3_t m_vecTargetAcceleration;
	vec3_t m_vecAcceleration;
	float m_flAccelerationWeight;
	float m_flAimMatrixTransition;
	float m_flAimMatrixTransitionDelay;
	bool m_bFlashed;
	float m_flStrafeChangeWeight;
	float m_flStrafeChangeTargetWeight;
	float m_flStrafeChangeCycle;
	int m_nStrafeSequence;
	bool m_bStrafeChanging;
	float m_flDurationStrafing;
	float m_flFootLerp;
	bool m_bFeetCrossed;
	bool m_bPlayerIsAccelerating;
	animstate_pose_param_cache_t m_tPoseParamMappings[20];
	float m_flDurationMoveWeightIsTooHigh;
	float m_flStaticApproachSpeed;
	int m_nPreviousMoveState;
	float m_flStutterStep;
	float m_flActionWeightBiasRemainder;
	procedural_foot_t m_footLeft;
	procedural_foot_t m_footRight;
	float m_flCameraSmoothHeight;
	bool m_bSmoothHeightValid;
	float m_flLastTimeVelocityOverTen;
	float m_flAimYawMin;
	float m_flAimYawMax;
	float m_flAimPitchMin;
	float m_flAimPitchMax;
	int m_nAnimstateModelVersion;

	void update(const ang_t& angle)
	{
		static auto& invalidate_bone_cache = pattern::find(g_csgo.m_client_dll, "C6 05 ? ? ? ? ? 8B 01 FF 50 40 8B 1D ? ? ? ?").add(0x2);
		const auto oldbonecache = invalidate_bone_cache;
		update_(angle);
		invalidate_bone_cache = oldbonecache;
	}

	void update_(const ang_t& angle)
	{
		using update_animstate_fn = void(__vectorcall*)(CCSGOPlayerAnimState*, void*, float, float, float, void*);
		static auto update_animstate = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24")).as< update_animstate_fn>();
		if (!update_animstate)
			return;

		update_animstate(this, NULL, NULL, angle.y, angle.x, NULL);
	}

	const char* GetWeaponPrefix()
	{
		typedef const char* (__thiscall* fnGetWeaponPrefix)(void*);
		static const auto get_weapon_adr = pattern::find(g_csgo.m_client_dll, XOR("E8 ? ? ? ? 50 8D 44 24 54")).rel32(1).as< fnGetWeaponPrefix>();
		return get_weapon_adr(this);
	}
};

enum PLAYER_TEAM {
	TEAM_NONE = 0,
	TEAM_SPEC = 1,
	TEAM_TT,
	TEAM_CT
};

class Player : public Entity {
public:
	// netvars / etc.
	__forceinline vec3_t& m_vecAbsVelocity() {
		return get< vec3_t >(g_entoffsets.m_vecAbsVelocity);
	}

	__forceinline int& m_nExplodeEffectTickBegin() {
		return get< int >(g_entoffsets.m_nExplodeEffectTickBegin);
	}

	__forceinline e_life_state m_lifeState() {
		return get< e_life_state >(g_entoffsets.m_lifeState);
	}

	__forceinline int& m_fFlags() {
		return get< int >(g_entoffsets.m_fFlags);
	}

	__forceinline int& GetThinkTick() {
		return get < int >(0xF8);
	}

	__forceinline int& m_iOcclusionFramecount() {
		return get< int >(g_entoffsets.m_iOcclusionFramecount);
	}

	__forceinline int& m_iAccumulatedBoneMask() {
		return get< int >(g_entoffsets.m_iAccumulatedBoneMask);
	}

	__forceinline int& m_iOcclusionFlags() {
		return get< int >(g_entoffsets.m_iOcclusionFlags);
	}

	__forceinline bool& m_bUseNewAnimState() {
		return get< bool >(0x39E1);
	}

	__forceinline some_ptr_t*& some_ptr() {
		return *reinterpret_cast<some_ptr_t**>(reinterpret_cast<uintptr_t>(this) + 14612);
	}

	__forceinline void SetCurrentCommand(CUserCmd* cmd) {
		*(CUserCmd**)((uintptr_t)this + 0x3338) = cmd;
	}

	__forceinline CPlayerState& pl() {
		return *(CPlayerState*)((uintptr_t)this + g_entoffsets.pl);
	}

	__forceinline bool PhysicsRunThink(int think_method = 0) {
		return g_csgo.m_uImplPhysicsRunThink.as<bool(__thiscall*)(void*, int)>()(this, think_method);
	}

	__forceinline int& m_nNextThinkTick() {
		return get< int >(g_entoffsets.m_nNextThinkTick);
	}

	__forceinline void RunPreThink() {
		if (!this->PhysicsRunThink())
			return;

		this->PreThink();
	}


	__forceinline auto RunThink(double frametime) {

		int thinktick = this->m_nNextThinkTick();

		if (thinktick <= 0 || thinktick > this->m_nTickBase())
			return;

		{ /* C_BaseEntity::SetNextThink */
			this->m_nNextThinkTick() = -1;

			this->CheckHasThinkFunction(false);
		}

		this->Think();

	}

	__forceinline void CheckHasThinkFunction(bool is_thinking = false) {
		static auto oCheckHasThinkFunction = pattern::find(g_csgo.m_client_dll, XOR("E8 ? ? ? ? EB 11 8B 86 ? ? ? ?")).rel32(0x1).as< void(__thiscall*)(void*, bool) >();
		return oCheckHasThinkFunction(this, is_thinking);
	}

	__forceinline int SetNextThink(int tick) {
		return g_csgo.SetNextThink(this, tick);
	}

	Entity* get_view_model()
	{
		Entity* view_model = g_csgo.m_entlist->GetClientEntityFromHandle(this->m_hViewModel());
		return view_model;
	}

	__forceinline void Think() {
		const auto next_think = (int*)((uintptr_t)this + 0xF8);
		if (*next_think > 0 && *next_think <= this->m_nTickBase())
		{
			*next_think = -1;

			// unk func inside RunThink()
			g_csgo.think.as<void(__thiscall*)(void*, int)>()(this, 0);

			util::get_method< void(__thiscall*)(decltype(this)) >(this, 137)(this);
		}
	}


	__forceinline void PreThink() {
		util::get_method < void(__thiscall*)(void*) >(this, PRETHINK) (this);
	}

	__forceinline void PostThink() {
		util::get_method< void(__thiscall*)(void*) >(g_csgo.model_cache, 32)(g_csgo.model_cache);

		if (this->alive())
		{
			util::get_method< void(__thiscall*)(decltype(this)) >(this, 329)(this);

			if (this->m_fFlags() & FL_ONGROUND)
				this->m_flFallVelocity() = 0.f;

			if (this->m_nSequence() == -1)
				util::get_method< void(__thiscall*)(decltype(this), int) >(this, 213)(this, 0);

			util::get_method< void(__thiscall*)(decltype(this)) >(this, 214)(this);
			g_csgo.PostThinkVPhysics.as<bool(__thiscall*)(Player*)>()(this);
		}

		g_csgo.simulate_player_simulated_entities.as< void(__thiscall*)(Player*)>()(this);
		util::get_method< void(__thiscall*)(void*) >(g_csgo.model_cache, 33)(g_csgo.model_cache);
	}

	BYTE& m_ubEFNoInterpParity() {
		return *(BYTE*)(uintptr_t(this) + g_entoffsets.m_ubEFNoInterpParity);
	}

	BYTE& m_ubEFNoInterpParityOld() {
		return *(BYTE*)(uintptr_t(this) + g_entoffsets.m_ubEFNoInterpParity + 1);
	}

	__forceinline bool& m_bIsWalking() {
		return get< bool >(g_entoffsets.m_bIsWalking);
	}

	__forceinline int& m_MoveType() {
		return get< int >(g_entoffsets.m_MoveType);
	}

	__forceinline int& m_iHealth() {
		return get< int >(g_entoffsets.m_iHealth);
	}

	__forceinline vec3_t* m_vecBonePos() {
		return (vec3_t*)((uintptr_t)this + g_entoffsets.m_nCachedBonesPosition);
	}

	__forceinline quaternion_t* m_quatBoneRot() {
		return (quaternion_t*)((uintptr_t)this + g_entoffsets.m_nCachedBonesRotation);
	}

	__forceinline int& m_iAccount() {
		return get< int >(g_entoffsets.m_iAccount);
	}

	__forceinline bool& m_bHasDefuser() {
		return get< bool >(g_entoffsets.m_bHasDefuser);
	}

	__forceinline int& m_nHitboxSet() {
		return get< int >(g_entoffsets.m_nHitboxSet);
	}

	__forceinline ang_t& m_angAbsRotation() {
		return get< ang_t >(g_entoffsets.m_angAbsRotation);
	}

	__forceinline ang_t& m_angRotation() {
		return get< ang_t >(g_entoffsets.m_angRotation);
	}

	__forceinline ang_t& m_angNetworkAngles() {
		return get< ang_t >(g_entoffsets.m_angNetworkAngles);
	}

	_forceinline std::optional<vec3_t> GetHitboxPosition(const int hitbox) {
		assert(hitbox > -1 && hitbox < HITBOX_MAX); // given invalid hitbox index for gethitboxposition

		std::array<matrix3x4_t, 128> bonesToWorld = { };

		if (const auto model = this->GetModel(); model != nullptr) {
			if (const auto studioHdr = g_csgo.m_model_info->GetStudioModel(model); studioHdr != nullptr) {
				if (const auto studioHitbox = studioHdr->GetHitbox(hitbox, 0); studioHitbox != nullptr) {
					if (this->SetupBones(bonesToWorld.data(), bonesToWorld.size(), BONE_USED_BY_HITBOX, 0.f)) {
						// get mins/maxs by bone
						const vec3_t min = math::VectorAmogus(studioHitbox->m_mins, bonesToWorld.at(studioHitbox->m_bone));
						const vec3_t max = math::VectorAmogus(studioHitbox->m_maxs, bonesToWorld.at(studioHitbox->m_bone));

						return (min + max) * 0.5;
					}
				}
			}
		}

		return std::nullopt;
	}

	__forceinline vec3_t GetHitboxPositionPeek(int h, matrix3x4_t* matrix) {
		const model_t* pModel = this->GetModel();
		if (!pModel)
			return m_vecOrigin();

		studiohdr_t* pHdr = g_csgo.m_model_info->GetStudioModel(pModel);
		if (!pHdr)
			return m_vecOrigin();

		mstudiohitboxset_t* pSet = pHdr->GetHitboxSet(this->m_nHitboxSet());

		if (!pSet)
			return m_vecOrigin();

		int hi = std::clamp<int>(h, 0, pSet->m_hitboxes - 1);

		mstudiobbox_t* pBox = pSet->GetHitbox(hi);
		if (!pBox)
			return m_vecOrigin();

		vec3_t vPos = (pBox->m_mins + pBox->m_maxs) * 0.5f;
		vec3_t vOut = m_vecOrigin();

		math::VectorTransform(vPos, matrix[pBox->m_bone], vOut);

		return vOut;
	}

	__forceinline bool m_bIsLocalPlayer() {
		// .text:101E0078 674     84 C0				   test    al, al          ; Logical Compare
		// .text:101E007A 674     74 17				   jz      short loc_101E0093; Jump if Zero( ZF = 1 )
		// .text:101E007C 674     8A 83 F8 35 00 00	   mov     al, [ ebx + 35F8h ]
		return get< bool >(g_csgo.IsLocalPlayer);
	}

	__forceinline CCSGOPlayerAnimState* m_PlayerAnimState() {
		// .text:1037A5B8 00C     E8 E3 40 E6 FF         call    C_BasePlayer__Spawn ; Call Procedure
		// .text:1037A5BD 00C     80 BE E1 39 00 00 00   cmp     byte ptr[ esi + 39E1h ], 0; Compare Two Operands
		// .text:1037A5C4 00C     74 48                  jz      short loc_1037A60E; Jump if Zero( ZF = 1 )
		// .text:1037A5C6 00C     8B 8E 74 38 00 00      mov     ecx, [ esi + 3874h ]; this
		// .text:1037A5CC 00C     85 C9                  test    ecx, ecx; Logical Compare
		// .text:1037A5CE 00C     74 3E                  jz      short loc_1037A60E; Jump if Zero( ZF = 1 )
		return get< CCSGOPlayerAnimState* >(g_csgo.PlayerAnimState);
	}

	__forceinline ulong_t& m_iMostRecentModelBoneCounter() {
		// .text:101AC9A9 000    89 81 80 26 00 00    mov[ ecx + 2680h ], eax
		return get< ulong_t >(g_csgo.MostRecentModelBoneCounter);
	}

	__forceinline float& m_flLastBoneSetupTime() {
		// .text:101AC99F 000    C7 81 14 29 00 00 FF FF+    mov     dword ptr [ecx+2914h], 0FF7FFFFFh;
		return get< float >(g_csgo.LastBoneSetupTime);
	}

	__forceinline int& m_nTickBase() {
		return get< int >(g_entoffsets.m_nTickBase);
	}

	__forceinline float& m_flNextAttack() {
		return get< float >(g_entoffsets.m_flNextAttack);
	}

	__forceinline float& m_flDuckAmount() {
		return get< float >(g_entoffsets.m_flDuckAmount);
	}

	__forceinline float& m_flVelocityModifier() {
		return get< float >(g_entoffsets.m_flVelocityModifier);
	}

	__forceinline float& m_flSimulationTime() {
		return get< float >(g_entoffsets.m_flSimulationTime);
	}

	__forceinline float& m_flOldSimulationTime() {
		return get< float >(g_entoffsets.m_flOldSimulationTime);
	}

	__forceinline float& m_flLowerBodyYawTarget() {
		return get< float >(g_entoffsets.m_flLowerBodyYawTarget);
	}

	__forceinline float& m_fImmuneToGunGameDamageTime() {
		return get< float >(g_entoffsets.m_fImmuneToGunGameDamageTime);
	}

	__forceinline bool& m_bHasHelmet() {
		return get< bool >(g_entoffsets.m_bHasHelmet);
	}

	__forceinline bool& m_bClientSideAnimation() {
		return get< bool >(g_entoffsets.m_bClientSideAnimation);
	}

	__forceinline bool& m_bHasHeavyArmor() {
		return get< bool >(g_entoffsets.m_bHasHeavyArmor);
	}

	__forceinline bool& m_bIsScoped() {
		return get< bool >(g_entoffsets.m_bIsScoped);
	}

	__forceinline bool& m_bDucking() {
		return get< bool >(g_entoffsets.m_bDucking);
	}

	__forceinline bool& m_bSpotted() {
		return get< bool >(g_entoffsets.m_bSpotted);
	}

	__forceinline int& m_iObserverMode() {
		return get< int >(g_entoffsets.m_iObserverMode);
	}

	__forceinline int& m_ArmorValue() {
		return get< int >(g_entoffsets.m_ArmorValue);
	}

	__forceinline float& m_flMaxspeed() {
		return get< float >(g_entoffsets.m_flMaxspeed);
	}

	__forceinline float& m_surfaceFriction() {
		return get< float >(g_entoffsets.m_surfaceFriction);
	}

	__forceinline float& m_fAccuracyPenalty() {
		return get< float >(g_entoffsets.m_fAccuracyPenalty);
	}


	__forceinline float& m_flFlashBangTime() {
		return get< float >(g_entoffsets.m_flFlashBangTime);
	}

	__forceinline ang_t& m_angEyeAngles() {
		return get< ang_t >(g_entoffsets.m_angEyeAngles);
	}

	__forceinline ang_t& m_aimPunchAngle() {
		return get< ang_t >(g_entoffsets.m_aimPunchAngle);
	}

	__forceinline ang_t& m_viewPunchAngle() {
		return get< ang_t >(g_entoffsets.m_viewPunchAngle);
	}

	__forceinline ang_t& m_aimPunchAngleVel() {
		return get< ang_t >(g_entoffsets.m_aimPunchAngleVel);
	}

	__forceinline vec3_t& m_vecViewOffset() {
		return get< vec3_t >(g_entoffsets.m_vecViewOffset);
	}

	__forceinline CUserCmd& m_PlayerCommand() {
		return get< CUserCmd >(g_entoffsets.m_PlayerCommand);
	}

	__forceinline CUserCmd*& m_pCurrentCommand() {
		return get< CUserCmd* >(g_entoffsets.m_pCurrentCommand);
	}

	__forceinline auto& m_LastCmd() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("8D 8E ? ? ? ? 89 5C 24 3C")).add(0x2).to< std::size_t >();
		return *reinterpret_cast<CUserCmd*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_afButtonForced() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("8B 86 ? ? ? ? 09 47 30")).add(0x2).to< std::size_t >();
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_afButtonDisabled() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x2).to().sub< std::size_t >(0x4);
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_nImpulse() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x4).to().add< std::size_t >(0x10);
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_afButtonLast() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x4).to< std::size_t >();
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_afButtonPressed() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x4).to().add< std::size_t >(0x4);
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_afButtonReleased() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x4).to().add< std::size_t >(0x8);
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto& m_nButtons() {
		static auto offset = pattern::find(g_csgo.m_client_dll, XOR("33 CA 89 86 ? ? ? ?")).add(0x4).to().add< std::size_t >(0xc);
		return *reinterpret_cast<int*>(reinterpret_cast<std::size_t>(this) + offset);
	}

	__forceinline auto UpdateButtonState(int user_cmd_button_mask) {
		m_afButtonLast() = m_nButtons();

		m_nButtons() = user_cmd_button_mask;
		int buttons_changed = m_afButtonLast() ^ m_nButtons();

		m_afButtonPressed() = buttons_changed & m_nButtons();
		m_afButtonReleased() = buttons_changed & (~m_nButtons());
	}

	__forceinline int& m_iEFlags() {
		return get< int >(g_entoffsets.m_iEFlags);
	}

	__forceinline CBaseHandle* m_hMyWearables() {
		return (CBaseHandle*)((uintptr_t)this + g_entoffsets.m_hMyWearables);
	}

	__forceinline float SequenceDuration(int sequence) {
		static auto addr = pattern::find(g_csgo.m_client_dll, XOR("55 8B EC 56 8B F1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 83 C4 04 5E 5D C2 04 00 52 68 ? ? ? ? 6A 02")).as < float(__thiscall*)(void*, int) >();

		float retval;
		addr(this, sequence);
		__asm movss retval, xmm0;

		return retval;
	}

	__forceinline float GetSequenceCycleRate(int sequence) {
		float t = SequenceDuration(sequence);

		if (t > 0.0f)
			return 1.0f / t;
		else
			return 1.0f / 0.1f;
	}

	__forceinline int LookupSequence(const char* label) {
		static auto oLookupSequence = pattern::find(g_csgo.m_client_dll, XOR("E8 ? ? ? ? 8B D0 89 54 24 18 83 FA FF 75 11")).rel32(0x1).as< int(__thiscall*)(void*, const char*) >();
		return oLookupSequence(this, label);
	}

	__forceinline CBoneCache& m_BoneCache() {
		// TODO; sig
		return get< CBoneCache >(g_entoffsets.m_BoneCache);
	}

	__forceinline matrix3x4_t**& m_iBoneCache() {
		// TODO; sig
		return get< matrix3x4_t** >(g_entoffsets.m_BoneCache);
	}

	__forceinline matrix3x4_t* m_MatrixBoneCache() {
		// TODO; sig
		return *get< matrix3x4_t** >(g_entoffsets.m_BoneCache);
	}

	__forceinline CBoneCache& bone_cache1() {
		// TODO; sig
		return get< CBoneCache >(g_entoffsets.m_BoneCache);
	}

	__forceinline EHANDLE& m_hObserverTarget() {
		return get< EHANDLE >(g_entoffsets.m_hObserverTarget);
	}

	__forceinline EHANDLE& m_hActiveWeapon() {
		return get< EHANDLE >(g_entoffsets.m_hActiveWeapon);
	}

	__forceinline EHANDLE& m_hGroundEntity() {
		return get< EHANDLE >(g_entoffsets.m_hGroundEntity);
	}

	__forceinline CBaseHandle* m_hMyWeapons() {
		return (CBaseHandle*)((uintptr_t)this + g_entoffsets.m_hMyWeapons);
	}

	__forceinline C_AnimationLayer* m_AnimOverlay() {
		// .text:1017EAB1 08C    8B 47 1C                mov     eax, [edi+1Ch]
		// .text:1017EAB4 08C    8D 0C D5 00 00 00 00    lea     ecx, ds:0[ edx * 8 ]; Load Effective Address
		// .text:1017EABB 08C    2B CA                   sub     ecx, edx; Integer Subtraction
		// .text:1017EABD 08C    8B 80 70 29 00 00       mov     eax, [ eax + 2970h ]
		// .text:1017EAC3 08C    8D 34 C8                lea     esi, [ eax + ecx * 8 ]; Load Effective Address
		// .text:1017EAC6
		return get< C_AnimationLayer* >(g_csgo.AnimOverlay);
	}

	__forceinline int m_AnimOverlayCount() {
		// .text:1017EAB1 08C    8B 47 1C                mov     eax, [edi+1Ch]
		// .text:1017EAB4 08C    8D 0C D5 00 00 00 00    lea     ecx, ds:0[ edx * 8 ]; Load Effective Address
		// .text:1017EABB 08C    2B CA                   sub     ecx, edx; Integer Subtraction
		// .text:1017EABD 08C    8B 80 70 29 00 00       mov     eax, [ eax + 2970h ]
		// .text:1017EAC3 08C    8D 34 C8                lea     esi, [ eax + ecx * 8 ]; Load Effective Address
		// .text:1017EAC6
		return get< int >(g_csgo.AnimOverlay + 0xC);
	}

	__forceinline void SetMins(vec3_t& mins) {
		*(vec3_t*)((DWORD)this + g_entoffsets.m_vecMins) = mins;
	}

	__forceinline void SetMaxs(vec3_t& maxs) {
		*(vec3_t*)((DWORD)this + g_entoffsets.m_vecMaxs) = maxs;
	}

	__forceinline EHANDLE& m_MoveParent() {
		return get< EHANDLE >(g_entoffsets.moveparent);
	}

	__forceinline float& m_flSpawnTime() {
		// .text:10381AB3 00C    F3 0F 10 49 10             movss   xmm1, dword ptr [ecx+10h] ; Move Scalar Single-FP
		// .text:10381AB8 00C    F3 0F 5C 88 90 A2 00 00    subss   xmm1, dword ptr[ eax + 0A290h ]; Scalar Single - FP Subtract
		return get< float >(g_csgo.SpawnTime);
	}

	__forceinline int& m_iPrevBoneMask() {
		return get< int >(g_entoffsets.m_iPrevBoneMask);
	}

	__forceinline CBoneAccessor& m_BoneAccessor() {
		// .text:101A9253 1C4    C7 81 A0 26 00 00 00 FF 0F 00    mov     dword ptr[ ecx + 26A0h ], 0FFF00h
		// .text:101A925D 1C4    C7 81 9C 26 00 00 00 FF 0F 00    mov     dword ptr[ ecx + 269Ch ], 0FFF00h
		// .text:101A9267 1C4    8B 10                            mov     edx, [ eax ]
		// .text:101A9269 1C4    8D 81 94 26 00 00                lea     eax, [ ecx + 2694h ]; Load Effective Address
		// .text:101A926F 1C4    50                               push    eax
		return get< CBoneAccessor >(g_csgo.BoneAccessor);
	}

	void calc_absolute_position()
	{
		g_csgo.calc_absolute_position.as<void(__thiscall*)(decltype(this))>()(this);
	}

	__forceinline void interpolate_moveparent_pos()
	{
		// update moveparent + local pos
		calc_absolute_position();

		// mark that we gonna change our pos
		InvalidatePhysicsRecursive(POSITION_CHANGED);

		auto moveparent = g_csgo.m_entlist->GetClientEntityFromHandle(m_MoveParent());
		if (moveparent)
		{
			// set new moveparent pos to interpolated one
			auto& frame = moveparent->m_hCoordFrame();
			frame.SetOrigin(GetAbsOrigin());
		}
	}

	__forceinline void set_bone_cache(matrix3x4_t* matrix)
	{
		auto cache = m_BoneCache();
		if (!cache.m_pCachedBones)
			return;

		std::memcpy(cache.m_pCachedBones, matrix, sizeof(matrix3x4_t) * cache.m_CachedBoneCount);
		std::memcpy(m_BoneAccessor().m_pBones, matrix, sizeof(matrix3x4_t) * cache.m_CachedBoneCount);
	}

	__forceinline void store_bone_cache(matrix3x4_t* matrix) {
		std::memcpy(matrix, this->m_BoneCache().m_pCachedBones, sizeof(matrix3x4_t) * this->m_BoneCache().m_CachedBoneCount);
	}

public:
	enum indices : size_t {
		GETREFEHANDLE = 2,
		TESTHITBOXES = 52,
		BUILDTRANSFORMATIONS = 184,
		CALCULATEIKLOCKS = 187,
		DOEXTRABONEPROCESSING = 192,
		STANDARDBLENDINGRULES = 200,
		ACCUMULATELAYERS = 201,
		UPDATECLIENTSIDEANIMATION = 218, // 55 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74 36
		UPDATEDISPATCHLAYER = 241, 
		GETACTIVEWEAPON = 262,
		GETEYEPOS = 163,
		PRETHINK = 307,
		GETFOV = 321,
		SELECTITEM = 319,
		UPDATECOLLISIONBOUNDS = 329, // 56 57 8B F9 8B 0D ? ? ? ? F6 87 ? ? ? ? ?
		SETLOCALVIEWANGLES = 362
	};

public:
	int lookup_bone(const char* name) {
		static auto function = pattern::find(g_csgo.m_client_dll, "E8 ? ? ? ? 89 44 24 5C").relative().as< int(__thiscall*)(void*, const char*) >();

		return function(this, name);
	}

	// virtuals.
	__forceinline ulong_t GetRefEHandle() {
		using GetRefEHandle_t = ulong_t(__thiscall*)(decltype(this));
		return util::get_method< GetRefEHandle_t >(this, GETREFEHANDLE)(this);
	}

	__forceinline void BuildTransformations(CStudioHdr* hdr, vec3_t* pos, quaternion_t* q, const matrix3x4_t& transform, int mask, uint8_t* computed) {
		using BuildTransformations_t = void(__thiscall*)(decltype(this), CStudioHdr*, vec3_t*, quaternion_t*, matrix3x4_t const&, int, uint8_t*);
		return util::get_method< BuildTransformations_t >(this, BUILDTRANSFORMATIONS)(this, hdr, pos, q, transform, mask, computed);
	}

	__forceinline void StandardBlendingRules(CStudioHdr* hdr, vec3_t* pos, quaternion_t* q, float time, int mask) {
		using StandardBlendingRules_t = void(__thiscall*)(decltype(this), CStudioHdr*, vec3_t*, quaternion_t*, float, int);
		return util::get_method< StandardBlendingRules_t >(this, STANDARDBLENDINGRULES)(this, hdr, pos, q, time, mask);
	}

	__forceinline void SelectItem(const char* str, int sub_type) {
		using SelectItem_t = void(__thiscall*)(decltype(this), const char*, int);
		return util::get_method< SelectItem_t >(this, SELECTITEM)(this, str, sub_type);
	}

	__forceinline void CalculateIKLocks(float time) {
		using CalculateIKLocksFn = void(__thiscall*)(void*, float);
		return util::get_method< CalculateIKLocksFn >(this, CALCULATEIKLOCKS)(this, time);
	}

	__forceinline bool UpdateDispatchLayer(C_AnimationLayer* layer, CStudioHdr* studio_hdr, int sequence) {
		return util::get_method< bool(__thiscall*)(decltype(this), C_AnimationLayer*, CStudioHdr*, int)>(this, UPDATEDISPATCHLAYER)(this, layer, studio_hdr, sequence);
	}

	__forceinline void SetLocalViewAngles(ang_t& angles) {
		util::get_method<void(__thiscall*)(decltype(this), ang_t&)>(this, SETLOCALVIEWANGLES)(this, angles);
	}

	__forceinline float GetFOV() {
		return util::get_method< float(__thiscall*)(decltype(this)) >(this, GETFOV)(this);
	}

	__forceinline const vec3_t& WorldSpaceCenter() {
		return util::get_method< const vec3_t & (__thiscall*)(void*) >(this, WORLDSPACECENTER)(this);
	}

	__forceinline void GetEyePos(vec3_t* pos) {
		util::get_method< void(__thiscall*)(decltype(this), vec3_t*) >(this, GETEYEPOS)(this, pos);
	}

	__forceinline float GetLayerSequenceCycleRate(C_AnimationLayer* layer, int sequence) {
		return util::get_method<float(__thiscall*)(void*, C_AnimationLayer*, int)>(this, 217)(this, layer, sequence);
	}

	__forceinline void get_eye_pos(vec3_t& out)
	{
		util::get_method<void(__thiscall*)(void*, vec3_t&)>(this, 277)(this, out);
	}

	__forceinline void ModifyEyePosition( CCSGOPlayerAnimState* animstate, vec3_t* pos, matrix3x4_t* m) {
		if (!animstate) {
			return;
		}

		static auto lookup_bone = pattern::find(g_csgo.m_client_dll, "E8 ? ? ? ? 89 44 24 5C").rel32(1).as<int(__thiscall*)(void*, const char*)>();

		if ((animstate->m_bLanding || animstate->m_flAnimDuckAmount != 0.f) && animstate->m_pPlayer->GetGroundEntity())
		{
			int bone_id = lookup_bone(animstate->m_pPlayer, "head_0");
			if (bone_id == -1)
				return;

			vec3_t bone_pos = m ? vec3_t(m[8][0][3], m[8][1][3], m[8][2][3]) : vec3_t(
				animstate->m_pPlayer->m_BoneCache().m_pCachedBones[8][0][3],
				animstate->m_pPlayer->m_BoneCache().m_pCachedBones[8][1][3],
				animstate->m_pPlayer->m_BoneCache().m_pCachedBones[8][2][3]);

			bone_pos.z += 1.7f;

			if (pos->z > bone_pos.z)
			{
				auto some_factor = 0.f;

				const auto delta = (*pos).z - bone_pos.z;
				const auto some_offset = (delta - 4.f) / 6.f;

				if (some_offset >= 0.f)
					some_factor = std::fminf(some_offset, 1.f);

				pos->z += (bone_pos.z - pos->z) * (some_factor * some_factor * 3.f - some_factor * some_factor * 2.f * some_factor);
			}
		}
	}

	__forceinline vec3_t GetShootPosition(matrix3x4_t* matrix = nullptr) {
		vec3_t pos;

		GetEyePos(&pos);

		if (*reinterpret_cast <int32_t*> (uintptr_t(this) + 0x39E1)) {
			auto v3 = m_PlayerAnimState();
			if (v3) {
				ModifyEyePosition(v3, &pos, matrix);
			}
		}

		return pos;
	}
	
	__forceinline void UpdateClientSideAnimation() {
		return util::get_method< void(__thiscall*)(decltype(this)) >(this, UPDATECLIENTSIDEANIMATION)(this);
	}

	void UpdateClientSideAnimationEx();

	__forceinline void UpdateCollisionBounds() {
		return util::get_method< void(__thiscall*)(decltype(this)) >(this, UPDATECOLLISIONBOUNDS)(this);
	}

	__forceinline int& sim_tick()
	{
		return *reinterpret_cast<int*> (
			reinterpret_cast<std::uintptr_t> (this) + 0x2a8u
			);
	}

	__forceinline void StudioFrameAdvance() {
		return util::get_method< void(__thiscall*)(decltype(this)) >(this, 214)(this);
	}


	__forceinline void SetSequence(int seq) {
		return util::get_method< void(__thiscall*)(decltype(this), int) >(this, 213)(this, seq);
	}

	__forceinline Weapon* GetActiveWeapon() {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >(m_hActiveWeapon());
	}

	__forceinline Entity* GetObserverTarget() {
		return g_csgo.m_entlist->GetClientEntityFromHandle(m_hObserverTarget());
	}

	__forceinline Entity* GetGroundEntity() {

		return g_csgo.m_entlist->GetClientEntityFromHandle(m_hGroundEntity());
	}

	__forceinline void SetAnimLayers(C_AnimationLayer* layers) {
		std::memcpy(m_AnimOverlay(), layers, sizeof(C_AnimationLayer) * 13);
	}

	__forceinline void GetAnimLayers(C_AnimationLayer* layers) {
		std::memcpy(layers, m_AnimOverlay(), sizeof(C_AnimationLayer) * 13);
	}

	__forceinline int GetNumAnimOverlays()
	{
		return *(int*)((DWORD)this + g_entoffsets.m_iNumOverlays);
	}

	__forceinline void SetPoseParameters(float* poses) {
		std::memcpy(m_flPoseParameter(), poses, sizeof(float) * 24);
	}

	__forceinline void GetPoseParameters(float* poses) {
		std::memcpy(poses, m_flPoseParameter(), sizeof(float) * 24);
	}

	__forceinline bool ComputeHitboxSurroundingBox(vec3_t* mins, vec3_t* maxs) {
		using ComputeHitboxSurroundingBox_t = bool(__thiscall*)(void*, vec3_t*, vec3_t*);

		return g_csgo.ComputeHitboxSurroundingBox.as< ComputeHitboxSurroundingBox_t >()(this, mins, maxs);
	}

	__forceinline int GetSequenceActivity(int sequence) {
		using GetSequenceActivity_t = int(__fastcall*)(CStudioHdr*, int);

		return g_csgo.GetSequenceActivity.as< GetSequenceActivity_t >()(GetModelPtr(), sequence);
	}

	__forceinline bool HasC4() {
		using HasC4_t = bool(__thiscall*)(decltype(this));
		return g_csgo.HasC4.as< HasC4_t >()(this);
	}

	__forceinline void InvalidateBoneCache() {
		auto* casted = reinterpret_cast<DWORD*>(this);
		casted[2629] = -8388609;
		casted[2464] = 0;
	}

	__forceinline void RemoveIKContext() {
		this->m_pIKContext() = nullptr;
		this->m_ClientEntEffects() |= 2u;
	}

	__forceinline bool alive() {
		return m_lifeState() == e_life_state::alive && m_iHealth() > 0;
	}

	__forceinline bool enemy(Player* from) {
		if (m_iTeamNum() != from->m_iTeamNum())
			return true;

		else if (g_csgo.mp_teammates_are_enemies->GetInt())
			return true;

		return false;
	}

	__forceinline void SetCollisionBounds(const vec3_t& mins, const vec3_t& maxs) {
		g_csgo.SetCollisionBounds(GetCollideable(), mins, maxs);
	}

	__forceinline bool& m_bIsJiggleBonesEnabled() {
		return get< bool >(0x291C);
	}


	static void SetPredictionRandomSeed(const CUserCmd* cmd);
	static void SetPredictionPlayer(Player* player);

};

class ViewModel : public Player {
public:
};

class WeaponInfo {
private:
	PAD(0x4);											// 0x0000

public:
	const char* m_weapon_name;						// 0x0004 -- actual weapon name, even for usp-s and revolver. ex: "weapon_revolver"
	PAD(0xC);												// 0x0008
	int               m_max_clip1;							// 0x0014
	int				  m_max_clip2;							// 0x0018
	int				  m_default_clip1;						// 0x001C
	int		          m_default_clip2;						// 0x0020
	int               m_max_reserve;						// 0x0024
	PAD(0x4);												// 0x0028
	const char* m_world_model;						// 0x002C
	const char* m_view_model;							// 0x0030
	const char* m_world_dropped_model;				// 0x0034
	PAD(0x48);											// 0x0038
	const char* m_ammo_type;							// 0x0080
	uint8_t           pad_0084[4];						// 0x0084
	const char* m_sfui_name;							// 0x0088
	const char* m_deprecated_weapon_name;				// 0x008C -- shitty weapon name, shows "weapon_deagle" for revolver / etc.
	uint8_t           pad_0090[56];						// 0x0090
	CSWeaponType      m_weapon_type;						// 0x00C8
	int			      m_in_game_price;						// 0x00CC
	int               m_kill_award;							// 0x00D0
	const char* m_animation_prefix;					// 0x00D4
	float			  m_cycletime;							// 0x00D8
	float			  m_cycletime_alt;						// 0x00DC
	float			  m_time_to_idle;						// 0x00E0
	float			  m_idle_interval;						// 0x00E4
	bool			  m_is_full_auto;						// 0x00E5
	PAD(0x3);												// 0x00E8
	int               m_damage;								// 0x00EC
	float             m_armor_ratio;						// 0x00F0
	int               m_bullets;							// 0x00F4
	float             m_penetration;						// 0x00F8
	float             m_flinch_velocity_modifier_large;		// 0x00FC
	float             m_flinch_velocity_modifier_small;		// 0x0100
	float             m_range;								// 0x0104
	float             m_range_modifier;						// 0x0108
	float			  m_throw_velocity;						// 0x010C
	PAD(0xC);												// 0x0118
	bool			  m_has_silencer;						// 0x0119
	PAD(0x3);												// 0x011C
	const char* m_silencer_model;						// 0x0120
	int				  m_crosshair_min_distance;				// 0x0124
	int				  m_crosshair_delta_distance;			// 0x0128
	float             m_max_player_speed;					// 0x012C
	float             m_max_player_speed_alt;				// 0x0130
	float			  m_spread;								// 0x0134
	float			  m_spread_alt;							// 0x0138
	float             m_inaccuracy_crouch;					// 0x013C
	float             m_inaccuracy_crouch_alt;				// 0x0140
	float             m_inaccuracy_stand;					// 0x0144
	float             m_inaccuracy_stand_alt;				// 0x0148
	float             m_inaccuracy_jump_initial;			// 0x014C
	float             m_inaccuracy_jump;					// 0x0150
	float             m_inaccuracy_jump_alt;				// 0x0154
	float             m_inaccuracy_land;					// 0x0158
	float             m_inaccuracy_land_alt;				// 0x015C
	float             m_inaccuracy_ladder;					// 0x0160
	float             m_inaccuracy_ladder_alt;				// 0x0164
	float             m_inaccuracy_fire;					// 0x0168
	float             m_inaccuracy_fire_alt;				// 0x016C
	float             m_inaccuracy_move;					// 0x0170
	float             m_inaccuracy_move_alt;				// 0x0174
	float             m_inaccuracy_reload;					// 0x0178
	int               m_recoil_seed;						// 0x017C
	float			  m_recoil_angle;						// 0x0180
	float             m_recoil_angle_alt;					// 0x0184
	float             m_recoil_angle_variance;				// 0x0188
	float             m_recoil_angle_variance_alt;			// 0x018C
	float             m_recoil_magnitude;					// 0x0190
	float             m_recoil_magnitude_alt;				// 0x0194
	float             m_recoil_magnitude_variance;			// 0x0198
	float             m_recoil_magnitude_variance_alt;		// 0x019C
	float             m_recovery_time_crouch;				// 0x01A0
	float             m_recovery_time_stand;				// 0x01A4
	float             m_recovery_time_crouch_final;			// 0x01A8
	float             m_recovery_time_stand_final;			// 0x01AC
	float             m_recovery_transition_start_bullet;	// 0x01B0
	float             m_recovery_transition_end_bullet;		// 0x01B4
	bool			  m_unzoom_after_shot;					// 0x01B5
	PAD(0x3);												// 0x01B8
	bool		      m_hide_view_model_zoomed;				// 0x01B9
	bool			  m_zoom_levels;						// 0x01BA
	PAD(0x2);												// 0x01BC
	int				  m_zoom_fov[2];						// 0x01C4
	float			  m_zoom_time[3];						// 0x01D0
	PAD(0x8);												// 0x01D8
	float             m_addon_scale;						// 0x01DC
	PAD(0x8);												// 0x01E4
	int				  m_tracer_frequency;					// 0x01E8
	int				  m_tracer_frequency_alt;				// 0x01EC
	PAD(0x18);											// 0x0200
	int				  m_health_per_shot;					// 0x0204
	PAD(0x8);												// 0x020C
	float			  m_inaccuracy_pitch_shift;				// 0x0210
	float			  m_inaccuracy_alt_sound_threshold;		// 0x0214
	float			  m_bot_audible_range;					// 0x0218
	PAD(0x8);												// 0x0220
	const char* m_wrong_team_msg;						// 0x0224
	bool			  m_has_burst_mode;						// 0x0225
	PAD(0x3);												// 0x0228
	bool			  m_is_revolver;						// 0x0229
	bool			  m_can_shoot_underwater;				// 0x022A
	PAD(0x2);												// 0x022C			

};

class IRefCounted {
private:
	volatile long refCount;

public:
	virtual void destructor(char bDelete) = 0;
	virtual bool OnFinalRelease() = 0;

	void unreference() {
		if (InterlockedDecrement(&refCount) == 0 && OnFinalRelease()) {
			destructor(1);
		}
	}
};

class Weapon : public Entity {
public:
	using ref_vec_t = CUtlVector< IRefCounted* >;

	// netvars / etc.
	__forceinline ref_vec_t& m_CustomMaterials() {
		return get< ref_vec_t >(g_entoffsets.m_CustomMaterials);
	}

	__forceinline ref_vec_t& m_CustomMaterials2() {
		return get< ref_vec_t >(g_entoffsets.m_CustomMaterials2);
	}

	__forceinline ref_vec_t& m_VisualsDataProcessors() {
		return get< ref_vec_t >(g_entoffsets.m_VisualsDataProcessors);
	}

	__forceinline bool& m_bCustomMaterialInitialized() {
		return get< bool >(g_entoffsets.m_bCustomMaterialInitialized);
	}

	__forceinline int& m_iItemDefinitionIndex() {
		return get< int >(g_entoffsets.m_iItemDefinitionIndex);
	}

	__forceinline int& m_iClip1() {
		return get< int >(g_entoffsets.m_iClip1);
	}

	__forceinline int& m_iPrimaryReserveAmmoCount() {
		return get< int >(g_entoffsets.m_iPrimaryReserveAmmoCount);
	}

	__forceinline int& m_Activity() {
		return get< int >(g_entoffsets.m_Activity);
	}

	__forceinline float& m_fFireDuration() {
		return get< float >(g_entoffsets.m_fFireDuration);
	}

	__forceinline int& m_iBurstShotsRemaining() {
		return get< int >(g_entoffsets.m_iBurstShotsRemaining);
	}

	__forceinline float& m_flNextPrimaryAttack() {
		return get< float >(g_entoffsets.m_flNextPrimaryAttack);
	}

	__forceinline float& m_flNextSecondaryAttack() {
		return get< float >(g_entoffsets.m_flNextSecondaryAttack);
	}

	__forceinline float& m_flThrowStrength() {
		return get< float >(g_entoffsets.m_flThrowStrength);
	}

	__forceinline float& m_fNextBurstShot() {
		return get< float >(g_entoffsets.m_fNextBurstShot);
	}

	__forceinline int& m_zoomLevel() {
		return get< int >(g_entoffsets.m_zoomLevel);
	}

	__forceinline float& m_flRecoilIndex() {
		return get< float >(g_entoffsets.m_flRecoilIndex);
	}

	__forceinline int& m_weaponMode() {
		return get< int >(g_entoffsets.m_weaponMode);
	}

	__forceinline int& m_nFallbackPaintKit() {
		return get< int >(g_entoffsets.m_nFallbackPaintKit);
	}

	__forceinline int& m_nFallbackStatTrak() {
		return get< int >(g_entoffsets.m_nFallbackStatTrak);
	}

	__forceinline int& m_nFallbackSeed() {
		return get< int >(g_entoffsets.m_nFallbackSeed);
	}

	__forceinline float& m_flFallbackWear() {
		return get< float >(g_entoffsets.m_flFallbackWear);
	}

	__forceinline int& m_iViewModelIndex() {
		return get< int >(g_entoffsets.m_iViewModelIndex);
	}

	__forceinline int& m_iWorldModelIndex() {
		return get< int >(g_entoffsets.m_iWorldModelIndex);
	}

	__forceinline int& m_iAccountID() {
		return get< int >(g_entoffsets.m_iAccountID);
	}

	__forceinline int& m_iItemIDHigh() {
		return get< int >(g_entoffsets.m_iItemIDHigh);
	}

	__forceinline int& m_iEntityQuality() {
		return get< int >(g_entoffsets.m_iEntityQuality);
	}

	__forceinline int& m_OriginalOwnerXuidLow() {
		return get< int >(g_entoffsets.m_OriginalOwnerXuidLow);
	}

	__forceinline int& m_OriginalOwnerXuidHigh() {
		return get< int >(g_entoffsets.m_OriginalOwnerXuidHigh);
	}

	__forceinline bool& m_bPinPulled() {
		return get< bool >(g_entoffsets.m_bPinPulled);
	}

	__forceinline float& m_fThrowTime() {
		return get< float >(g_entoffsets.m_fThrowTime);
	}

	__forceinline EHANDLE& m_hWeapon() {
		return get< EHANDLE >(g_entoffsets.m_hWeapon);
	}

	__forceinline EHANDLE& m_hWeaponWorldModel() {
		return get< EHANDLE >(g_entoffsets.m_hWeaponWorldModel);
	}

	__forceinline EHANDLE& m_hOwnerEntity() {
		return get< EHANDLE >(g_entoffsets.m_hOwnerEntity);
	}

	__forceinline float& m_flConstraintRadius() {
		return get< float >(g_entoffsets.m_flConstraintRadius);
	}

	__forceinline float& m_fLastShotTime() {
		return get< float >(g_entoffsets.m_fLastShotTime);
	}

public:
	enum indices : size_t {
		SETMODELINDEX = 75,
		GETMAXCLIP1 = 367,
		GETSPREAD = 439,
		GETWPNDATA = 446, // C_WeaponCSBaseGun::GetCSWpnData
		GETINACCURACY = 469,
		UPDATEACCURACYPENALTY = 471,
	};

public:
	// virtuals.
	__forceinline int GetMaxClip1() {
		return util::get_method< int(__thiscall*)(void*) >(this, GETMAXCLIP1)(this);
	}

	__forceinline void SetGloveModelIndex(int index) {
		return util::get_method< void(__thiscall*)(void*, int) >(this, SETMODELINDEX)(this, index);
	}

	__forceinline WeaponInfo* GetWpnData() {
		return util::get_method< WeaponInfo * (__thiscall*)(void*) >(this, GETWPNDATA)(this);
	}

	__forceinline float GetInaccuracy() {
		return util::get_method< float(__thiscall*)(void*) >(this, GETINACCURACY)(this);
	}

	__forceinline float GetSpread() {
		return util::get_method< float(__thiscall*)(void*) >(this, GETSPREAD)(this);
	}

	__forceinline void UpdateAccuracyPenalty() {
		return util::get_method< void(__thiscall*)(void*) >(this, UPDATEACCURACYPENALTY)(this);
	}

	// misc funcs.
	__forceinline Weapon* GetWeapon() {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >(m_hWeapon());
	}

	__forceinline Weapon* GetWeaponWorldModel() {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >(m_hWeaponWorldModel());
	}

	__forceinline bool IsKnife() {
		return (GetWpnData()->m_weapon_type == WEAPONTYPE_KNIFE && m_iItemDefinitionIndex() != ZEUS);
	}


	__forceinline float max_speed(bool scoped) {
		float max_speed{ 260.f };

		if (GetWpnData()) {
			max_speed = scoped ? GetWpnData()->m_max_player_speed_alt : GetWpnData()->m_max_player_speed;
		}

		return max_speed;
	}

	__forceinline vec3_t CalculateSpread(int seed, float inaccuracy, float spread, bool revolver2 = false) {
		WeaponInfo* wep_info;
		int        item_def_index;
		float      recoil_index, r1, r2, r3, r4, s1, c1, s2, c2;

		// if we have no bullets, we have no spread.
		wep_info = GetWpnData();
		if (!wep_info || !wep_info->m_bullets)
			return {};

		// get some data for later.
		item_def_index = m_iItemDefinitionIndex();
		recoil_index = m_flRecoilIndex();

		g_csgo.RandomSeed(seed & 255); // the server only accounts for 255 seeds

		auto v1 = g_csgo.RandomFloat(0.f, 1.f);
		auto v2 = g_csgo.RandomFloat(0.f, M_PI * 2.f);

		float v3{ }, v4{ };
		if (g_csgo.weapon_accuracy_shotgun_spread_patterns->GetInt() > 0)
			g_csgo.GetShotgunSpread(item_def_index, 0, static_cast<int>(wep_info->m_bullets * recoil_index), &v4, &v3);
		else
		{
			v3 = g_csgo.RandomFloat(0.f, 1.f);
			v4 = g_csgo.RandomFloat(0.f, M_PI * 2.f);
		}

		if (recoil_index < 3.f && item_def_index == WEAPON_NEGEV)
		{
			for (auto i = 3; i > recoil_index; --i)
			{
				v1 *= v1;
				v3 *= v3;
			}

			v1 = 1.f - v1;
			v3 = 1.f - v3;
		}

		const auto _inaccuracy = v1 * inaccuracy;
		const auto _spread = v3 * spread;

		return { std::cos(v2) * _inaccuracy + std::cos(v4) * _spread, std::sin(v2) * _inaccuracy + std::sin(v4) * _spread, 0.f };
	}

	__forceinline vec3_t CalculateSpread(int seed, bool revolver2 = false) {
		return CalculateSpread(seed, GetInaccuracy(), GetSpread(), revolver2);
	}

	__forceinline std::string GetLocalizedName() {
		C_EconItemView* item_view;
		CEconItemDefinition* item_def;

		item_view = g_csgo.GetEconItemView(this);
		if (!item_view)
			return XOR("error");

		item_def = g_csgo.GetStaticData(item_view);
		if (!item_def)
			return XOR("error");

		return util::WideToMultiByte(g_csgo.m_localize->Find(item_def->GetItemBaseName()));
	}

	bool can_doubletap() {

		if (!this)
			return false;

		WeaponInfo* wpn_data = GetWpnData();

		if (wpn_data) {

			if (wpn_data->m_is_full_auto)
				return true;

			if (wpn_data->m_weapon_type == WEAPONTYPE_PISTOL)
				return true;
		}

		return false;
	}
};

class CTraceFilterSimple_game {
public:
	void* m_vmt;
	const Entity* m_pass_ent1;
	int             m_collision_group;
	ShouldHitFunc_t m_shouldhit_check_fn;

public:
	__forceinline CTraceFilterSimple_game() :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >() },
		m_pass_ent1{},
		m_collision_group{},
		m_shouldhit_check_fn{} {}

	__forceinline CTraceFilterSimple_game(const Entity* pass_ent1, int collision_group = COLLISION_GROUP_NONE, ShouldHitFunc_t shouldhit_check_fn = nullptr) :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >() },
		m_pass_ent1{ pass_ent1 },
		m_collision_group{ collision_group },
		m_shouldhit_check_fn{ shouldhit_check_fn } {}

	__forceinline bool ShouldHitEntity(Entity* entity, int contents_mask) {
		// note - dex; game is dumb, this gets the real vmt.
		void* real_vmt = *(void**)m_vmt;

		return util::get_method< bool(__thiscall*)(void*, Entity*, int) >(real_vmt, 0)(real_vmt, entity, contents_mask);
	}

	// note - dex; don't really care about calling the virtuals for these two functions, they only set members in the class for us.
	__forceinline void SetPassEntity(Entity* pass_ent1) {
		m_pass_ent1 = pass_ent1;

		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 2 )( m_vmt, pass_ent1 );
	}

	__forceinline void SetCollisionGroup(int collision_group) {
		m_collision_group = collision_group;

		// util::get_method< void (__thiscall *)( void *, int ) >( m_vmt, 3 )( m_vmt, collision_group );
	}
};

class CTraceFilterSkipTwoEntities_game {
public:
	void* m_vmt;
	const Entity* m_pass_ent1;
	int             m_collision_group;
	ShouldHitFunc_t m_shouldhit_check_fn;
	const Entity* m_pass_ent2;

public:
	__forceinline CTraceFilterSkipTwoEntities_game() :
		m_vmt{ g_csgo.CTraceFilterSkipTwoEntities_vmt.as< void* >() },
		m_pass_ent1{},
		m_collision_group{},
		m_shouldhit_check_fn{},
		m_pass_ent2{} {}

	__forceinline CTraceFilterSkipTwoEntities_game(const Entity* pass_ent1, const Entity* pass_ent2, int collision_group = COLLISION_GROUP_NONE, ShouldHitFunc_t shouldhit_check_fn = nullptr) :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >() },
		m_pass_ent1{ pass_ent1 },
		m_collision_group{ collision_group },
		m_shouldhit_check_fn{ shouldhit_check_fn },
		m_pass_ent2{ pass_ent2 } {}

	__forceinline bool ShouldHitEntity(Entity* entity, int contents_mask) {
		// note - dex; game is dumb, this gets the real vmt.
		void* real_vmt = *(void**)m_vmt;

		return util::get_method< bool(__thiscall*)(void*, Entity*, int) >(m_vmt, 0)(m_vmt, entity, contents_mask);
	}

	// note - dex; don't really care about calling the virtuals for these two functions, they only set members in the class for us.
	__forceinline void SetPassEntity(Entity* pass_ent1) {
		m_pass_ent1 = pass_ent1;

		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 2 )( m_vmt, pass_ent1 );
	}

	__forceinline void SetCollisionGroup(int collision_group) {
		m_collision_group = collision_group;

		// util::get_method< void (__thiscall *)( void *, int ) >( m_vmt, 3 )( m_vmt, collision_group );
	}

	__forceinline void SetPassEntity2(Entity* pass_ent2) {
		m_pass_ent2 = pass_ent2;
		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 4 )( m_vmt, pass_ent2 );
	}
};

class CCSGOGamePlayerAnimState {
public:
	const int* m_pLayerOrderPreset;
	bool m_bFirstRunSinceInit;
	bool m_bFirstFootPlantSinceInit;
	int m_iLastUpdateFrame;
	float m_flEyePositionSmoothLerp;
	float m_flStrafeChangeWeightSmoothFalloff;
	aimmatrix_transition_t m_tStandWalkAim;
	aimmatrix_transition_t m_tStandRunAim;
	aimmatrix_transition_t m_tCrouchWalkAim;
	int m_cachedModelIndex;
	float m_flStepHeightLeft;
	float m_flStepHeightRight;
	Weapon* m_pWeaponLastBoneSetup;
	Player* m_pPlayer;
	Weapon* m_pWeapon;
	Weapon* m_pWeaponLast;
	float m_flLastUpdateTime;
	int m_nLastUpdateFrame;
	float m_flLastUpdateIncrement;
	float m_flEyeYaw;
	float m_flEyePitch;
	float m_flFootYaw;
	float m_flFootYawLast;
	float m_flMoveYaw;
	float m_flMoveYawIdeal;
	float m_flMoveYawCurrentToIdeal;
	float m_flTimeToAlignLowerBody;
	float m_flPrimaryCycle;
	float m_flMoveWeight;
	float m_flMoveWeightSmoothed;
	float m_flAnimDuckAmount;
	float m_flDuckAdditional;
	float m_flRecrouchWeight;
	vec3_t	m_vecPositionCurrent;
	vec3_t	m_vecPositionLast;
	vec3_t	m_vecVelocity;
	vec3_t	m_vecVelocityNormalized;
	vec3_t	m_vecVelocityNormalizedNonZero;
	float m_flVelocityLengthXY;
	float m_flVelocityLengthZ;
	float m_flSpeedAsPortionOfRunTopSpeed;
	float m_flSpeedAsPortionOfWalkTopSpeed;
	float m_flSpeedAsPortionOfCrouchTopSpeed;
	float m_flDurationMoving;
	float m_flDurationStill;
	bool m_bOnGround;
	bool m_bLanding;
	float m_flJumpToFall;
	float m_flDurationInAir;
	float m_flLeftGroundHeight;
	float m_flLandAnimMultiplier;
	float m_flWalkToRunTransition;
	bool m_bLandedOnGroundThisFrame;
	bool m_bLeftTheGroundThisFrame;
	float m_flInAirSmoothValue;
	bool m_bOnLadder;
	float m_flLadderWeight;
	float m_flLadderSpeed;
	bool m_bWalkToRunTransitionState;
	bool m_bDefuseStarted;
	bool m_bPlantAnimStarted;
	bool m_bTwitchAnimStarted;
	bool m_bAdjustStarted;
	CUtlVector< uint16_t > m_ActivityModifiers;
	float m_flNextTwitchTime;
	float m_flTimeOfLastKnownInjury;
	float m_flLastVelocityTestTime;
	vec3_t m_vecVelocityLast;
	vec3_t m_vecTargetAcceleration;
	vec3_t m_vecAcceleration;
	float m_flAccelerationWeight;
	float m_flAimMatrixTransition;
	float m_flAimMatrixTransitionDelay;
	bool m_bFlashed;
	float m_flStrafeChangeWeight;
	float m_flStrafeChangeTargetWeight;
	float m_flStrafeChangeCycle;
	int m_nStrafeSequence;
	bool m_bStrafeChanging;
	float m_flDurationStrafing;
	float m_flFootLerp;
	bool m_bFeetCrossed;
	bool m_bPlayerIsAccelerating;
	//animstate_pose_param_cache_t m_tPoseParamMappings[20];
	float m_flDurationMoveWeightIsTooHigh;
	float m_flStaticApproachSpeed;
	int m_nPreviousMoveState;
	float m_flStutterStep;
	float m_flActionWeightBiasRemainder;
	procedural_foot_t m_footLeft;
	procedural_foot_t m_footRight;
	float m_flCameraSmoothHeight;
	bool m_bSmoothHeightValid;
	float m_flLastTimeVelocityOverTen;
	float m_flAimYawMin;
	float m_flAimYawMax;
	float m_flAimPitchMin;
	float m_flAimPitchMax;
	int m_nAnimstateModelVersion;

	__forceinline const char* GetWeaponPrefix() {
		static auto oGetWeaponPrefix = pattern::find(g_csgo.m_client_dll, XOR("53 56 8B F1 57 33 FF 8B 4E 60 8B 01 FF 90 ? ? ? ? 89 46 64 85")).as < const char* (__thiscall*) (void*) >();
		return oGetWeaponPrefix(this);
	}
};